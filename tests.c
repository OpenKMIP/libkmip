/* Copyright (c) 2018 The Johns Hopkins University/Applied Physics Laboratory
 * All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

#include <stdio.h>
#include "kmip.h"

int
report_encoding_test_result(struct kmip *ctx, const uint8 *expected,
                            const uint8 *observed, int result,
                            const char *function)
{
    if(result == KMIP_OK)
    {
        for(size_t i = 0; i < ctx->size; i++)
        {
            if(expected[i] != observed[i])
            {
                printf("FAIL - %s\n", function);
                printf("- byte mismatch at: %zu (exp: %X, obs: %X)\n",
                       i, expected[i], observed[i]);
                for(size_t j = 0; j < ctx->size; j++)
                {
                    printf("- %zu: %X - %X\n", j, expected[j], observed[j]);
                }
                return(1);
            }
        }
        
        printf("PASS - %s\n", function);
        return(0);
    }
    else
    {
        printf("FAIL - %s\n", function);
        if(result == KMIP_ERROR_BUFFER_FULL)
        {
            printf("- context buffer is full\n");
        }
        print_stack_trace(ctx);
        return(1);
    }
}

int
report_decoding_test_result(struct kmip *ctx, int comparison, int result,
                            const char *function)
{
    if(result == KMIP_OK)
    {
        if(comparison)
        {
            printf("PASS - %s\n", function);
            return(0);
        }
        else
        {
            printf("FAIL - %s\n", function);
            printf("- compared objects are not identical\n");
            return(1);
        }
    }
    else
    {
        printf("FAIL - %s\n", function);
        if(result == KMIP_ERROR_BUFFER_FULL)
        {
            printf("- context buffer is underfull\n");
        }
        print_stack_trace(ctx);
        return(1);
    }
}

int
test_buffer_full_and_resize(void)
{
    uint8 expected[40] = {
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 too_small[30] = {0};
    uint8 large_enough[40] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, too_small, ARRAY_LENGTH(too_small), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    int result = encode_protocol_version(&ctx, &pv);
    
    if(result == KMIP_ERROR_BUFFER_FULL)
    {
        kmip_reset(&ctx);
        kmip_set_buffer(&ctx, large_enough, ARRAY_LENGTH(large_enough));
        
        result = encode_protocol_version(&ctx, &pv);
        return(report_encoding_test_result(&ctx, expected, large_enough, result, 
                                  __func__));
    }
    else
    {
        printf("FAIL - %s\n", __func__);
        printf("- expected buffer full\n");
        return(1);
    }
}

int
test_is_tag_next(void)
{
    uint8 encoding[3] = {0x42, 0x00, 0x08};
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 *before = ctx.index;
    int result = 0;
    
    if(is_tag_next(&ctx, KMIP_TAG_ATTRIBUTE) == KMIP_FALSE)
    {
        printf("FAIL - %s\n", __func__);
        printf("- expected tag is not next\n");
        result = 1;
    }
    
    uint8 *after = ctx.index;
    
    if(before != after)
    {
        printf("FAIL - %s\n", __func__);
        printf("- tag checking modifies context buffer index\n");
        result = 1;
    }
    
    kmip_destroy(&ctx);
    
    if(result == 0)
    {
        printf("PASS - %s\n", __func__);
    }
    
    return(result);
}

int
test_get_num_items_next(void)
{
    uint8 encoding[168] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00        
    };

    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 *before = ctx.index;
    int result = 0;
    int count = 0;
    
    count = get_num_items_next(&ctx, KMIP_TAG_ATTRIBUTE);
    if(count != 3)
    {
        printf("FAIL - %s\n", __func__);
        printf("- expected item count not found (exp. 3, obs. %d)\n",
               count);
        result = 1;
    }
    
    uint8 *after = ctx.index;
    
    if(before != after)
    {
        printf("FAIL - %s\n", __func__);
        printf("- item count checking modifies context buffer index\n");
        result = 1;
    }
    
    kmip_destroy(&ctx);
    
    if(result == 0)
    {
        printf("PASS - %s\n", __func__);
    }
    
    return(result);
}

int
test_get_num_items_next_with_partial_item(void)
{
    uint8 encoding[136] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72 
    };

    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 *before = ctx.index;
    int result = 0;
    int count = 0;
    
    count = get_num_items_next(&ctx, KMIP_TAG_ATTRIBUTE);
    if(count != 2)
    {
        printf("FAIL - %s\n", __func__);
        printf("- expected item count not found (exp. 2, obs. %d)\n",
               count);
        result = 1;
    }
    
    uint8 *after = ctx.index;
    
    if(before != after)
    {
        printf("FAIL - %s\n", __func__);
        printf("- item count checking modifies context buffer index\n");
        result = 1;
    }
    
    kmip_destroy(&ctx);
    
    if(result == 0)
    {
        printf("PASS - %s\n", __func__);
    }
    
    return(result);
}

int
test_get_num_items_next_with_mismatch_item(void)
{
    uint8 encoding[80] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72 
    };

    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 *before = ctx.index;
    int result = 0;
    int count = 0;
    
    count = get_num_items_next(&ctx, KMIP_TAG_ATTRIBUTE);
    if(count != 1)
    {
        printf("FAIL - %s\n", __func__);
        printf("- expected item count not found (exp. 1, obs. %d)\n",
               count);
        result = 1;
    }
    
    uint8 *after = ctx.index;
    
    if(before != after)
    {
        printf("FAIL - %s\n", __func__);
        printf("- item count checking modifies context buffer index\n");
        result = 1;
    }
    
    kmip_destroy(&ctx);
    
    if(result == 0)
    {
        printf("PASS - %s\n", __func__);
    }
    
    return(result);
}

int
test_get_num_items_next_with_no_matches(void)
{
    uint8 encoding[80] = {
        0x42, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72 
    };

    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 *before = ctx.index;
    int result = 0;
    int count = 0;
    
    count = get_num_items_next(&ctx, KMIP_TAG_ATTRIBUTE);
    if(count != 0)
    {
        printf("FAIL - %s\n", __func__);
        printf("- expected item count not found (exp. 0, obs. %d)\n",
               count);
        result = 1;
    }
    
    uint8 *after = ctx.index;
    
    if(before != after)
    {
        printf("FAIL - %s\n", __func__);
        printf("- item count checking modifies context buffer index\n");
        result = 1;
    }
    
    kmip_destroy(&ctx);
    
    if(result == 0)
    {
        printf("PASS - %s\n", __func__);
    }
    
    return(result);
}

int
test_get_num_items_next_with_non_structures(void)
{
    uint8 encoding[144] = {
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x26,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35, 
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x11, 0x11, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x25,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35, 
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x11, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35, 
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00
    };

    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 *before = ctx.index;
    int result = 0;
    int count = 0;
    
    count = get_num_items_next(&ctx, KMIP_TAG_UNIQUE_IDENTIFIER);
    if(count != 3)
    {
        printf("FAIL - %s\n", __func__);
        printf("- expected item count not found (exp. 3, obs. %d)\n",
               count);
        result = 1;
    }
    
    uint8 *after = ctx.index;
    
    if(before != after)
    {
        printf("FAIL - %s\n", __func__);
        printf("- item count checking modifies context buffer index\n");
        result = 1;
    }
    
    kmip_destroy(&ctx);
    
    if(result == 0)
    {
        printf("PASS - %s\n", __func__);
    }
    
    return(result);
}

int
test_decode_int8_be(void)
{
    uint8 encoding[1] = {0x42};
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    int8 value = 0;
    
    int result = decode_int8_be(&ctx, &value);
    result = report_decoding_test_result(
        &ctx,
        value == 0x42, 
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_int32_be(void)
{
    uint8 encoding[4] = {0x11, 0x22, 0x33, 0x44};
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);

    int32 expected = 0x11223344;
    int32 observed = 0;
    
    int result = decode_int32_be(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_int64_be(void)
{
    uint8 encoding[8] = {
        0x01, 0xB6, 0x9B, 0x4B, 0xA5, 0x74, 0x92, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    int64 expected = 0x01B69B4BA5749200;
    int64 observed = 0;
    
    int result = decode_int64_be(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_integer(void)
{
    uint8 expected[16] = {
        0x42, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[16] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int result = encode_integer(&ctx, KMIP_TAG_DEFAULT, 8);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_integer(void)
{
    uint8 encoding[16] = {
        0x42, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00
    };

    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    int32 expected = 8;
    int32 observed = 0;
    
    int result = decode_integer(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_long(void)
{
    uint8 expected[16] = {
        0x42, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08,
        0x01, 0xB6, 0x9B, 0x4B, 0xA5, 0x74, 0x92, 0x00
    };
    
    uint8 observed[16] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int result = encode_long(&ctx, KMIP_TAG_DEFAULT, 123456789000000000);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_long(void)
{
    uint8 encoding[16] = {
        0x42, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x08,
        0x01, 0xB6, 0x9B, 0x4B, 0xA5, 0x74, 0x92, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    int64 expected = 0x01B69B4BA5749200;
    int64 observed = 0;
    
    int result = decode_long(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_enum(void)
{
    uint8 expected[16] = {
        0x42, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[16] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int result = encode_enum(&ctx, KMIP_TAG_DEFAULT, KMIP_CRYPTOALG_AES);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_enum(void)
{
    uint8 encoding[16] = {
        0x42, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    enum cryptographic_algorithm expected = KMIP_CRYPTOALG_AES;
    enum cryptographic_algorithm observed = 0;
    
    int result = decode_enum(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_bool(void)
{
    uint8 expected[16] = {
        0x42, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
    };
    
    uint8 observed[16] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int result = encode_bool(&ctx, KMIP_TAG_DEFAULT, KMIP_TRUE);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_bool(void)
{
    uint8 encoding[16] = {
        0x42, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    bool32 expected = KMIP_TRUE;
    bool32 observed = 0;
    
    int result = decode_bool(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_text_string(void)
{
    uint8 expected[24] = {
        0x42, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0B,
        0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F,
        0x72, 0x6C, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[24] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);

    struct text_string example = {0};
    example.value = "Hello World";
    example.size = 11;
    
    int result = encode_text_string(&ctx, KMIP_TAG_DEFAULT, &example);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_text_string(void)
{
    uint8 encoding[24] = {
        0x42, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x0B,
        0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x57, 0x6F,
        0x72, 0x6C, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);

    struct text_string expected = {0};
    expected.value = "Hello World";
    expected.size = 11;
    struct text_string observed = {0};
    
    int result = decode_text_string(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_text_string(&expected, &observed),
        result,
        __func__);
    free_text_string(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_byte_string(void)
{
    uint8 expected[16] = {
        0x42, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03,
        0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[16] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    uint8 str[3] = {0x01, 0x02, 0x03};
    
    struct byte_string example = {0};
    example.value = str;
    example.size = 3;
    
    int result = encode_byte_string(&ctx, KMIP_TAG_DEFAULT, &example);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_byte_string(void)
{
    uint8 encoding[16] = {
        0x42, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03,
        0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);

    uint8 str[3] = {0x01, 0x02, 0x03};
    
    struct byte_string expected = {0};
    expected.value = str;
    expected.size = 3;
    struct byte_string observed = {0};
    
    int result = decode_byte_string(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_byte_string(&expected, &observed),
        result,
        __func__);
    free_byte_string(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_date_time(void)
{
    uint8 expected[16] = {
        0x42, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x47, 0xDA, 0x67, 0xF8
    };
    
    uint8 observed[16] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int result = encode_date_time(&ctx, KMIP_TAG_DEFAULT, 1205495800);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_date_time(void)
{
    uint8 encoding[16] = {
        0x42, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x47, 0xDA, 0x67, 0xF8
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint64 expected = 1205495800;
    uint64 observed = 0;
    
    int result = decode_date_time(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_interval(void)
{
    uint8 expected[16] = {
        0x42, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x0D, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[16] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int result = encode_interval(&ctx, KMIP_TAG_DEFAULT, 864000);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_interval(void)
{
    uint8 encoding[16] = {
        0x42, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x0D, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint32 expected = 864000;
    uint32 observed = 0;
    
    int result = decode_interval(&ctx, KMIP_TAG_DEFAULT, &observed);
    result = report_decoding_test_result(
        &ctx,
        observed == expected,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_name(void)
{
    uint8 expected[48] = {
        0x42, 0x00, 0x53, 0x01, 0x00, 0x00, 0x00, 0x28,
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x09,
        0x54, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65,
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[48] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string value = {0};
    value.value = "Template1";
    value.size = 9;
    
    struct name n = {0};
    n.value = &value;
    n.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    
    int result = encode_name(&ctx, &n);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_name(void)
{
    uint8 encoding[48] = {
        0x42, 0x00, 0x53, 0x01, 0x00, 0x00, 0x00, 0x28,
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x09,
        0x54, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65,
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string value = {0};
    value.value = "Template1";
    value.size = 9;
    
    struct name expected = {0};
    expected.value = &value;
    expected.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    struct name observed = {0};
    
    int result = decode_name(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_name(&expected, &observed),
        result,
        __func__);
    free_name(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_unique_identifier(void)
{
    uint8 expected[88] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x50,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x11,
        0x55, 0x6E, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49,
        0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65,
        0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38,
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66,
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D,
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63,
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[88] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_UNIQUE_IDENTIFIER;
    attr.value = &uuid;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_unique_identifier(void)
{
    uint8 encoding[88] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x50,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x11,
        0x55, 0x6E, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49,
        0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65,
        0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38,
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66,
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D,
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63,
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_UNIQUE_IDENTIFIER;
    expected.value = &uuid;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_name(void)
{
    uint8 expected[72] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x40,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x04,
        0x4E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x28,
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x09,
        0x54, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65,
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[72] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string value = {0};
    value.value = "Template1";
    value.size = 9;
    
    struct name n = {0};
    n.value = &value;
    n.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_NAME;
    attr.value = &n;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_name(void)
{
    uint8 encoding[72] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x40,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x04,
        0x4E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x28,
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x09,
        0x54, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65,
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string value = {0};
    value.value = "Template1";
    value.size = 9;
    
    struct name n = {0};
    n.value = &value;
    n.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_NAME;
    expected.value = &n;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_object_type(void)
{
    uint8 expected[48] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x28,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x0B,
        0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x54,
        0x79, 0x70, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[48] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    enum object_type t = KMIP_OBJTYPE_SYMMETRIC_KEY;
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_OBJECT_TYPE;
    attr.value = &t;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_object_type(void)
{
    uint8 encoding[48] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x28,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x0B,
        0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x54,
        0x79, 0x70, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    enum object_type t = KMIP_OBJTYPE_SYMMETRIC_KEY;
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_OBJECT_TYPE;
    expected.value = &t;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_cryptographic_algorithm(void)
{
    uint8 expected[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72,
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C,
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00,
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[56] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    enum cryptographic_algorithm a = KMIP_CRYPTOALG_AES;
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    attr.value = &a;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_cryptographic_algorithm(void)
{
    uint8 encoding[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72,
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C,
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00,
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    enum cryptographic_algorithm a = KMIP_CRYPTOALG_AES;
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    expected.value = &a;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_cryptographic_length(void)
{
    uint8 expected[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72,
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65,
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[56] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int32 length = 128;
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    attr.value = &length;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_cryptographic_length(void)
{
    uint8 encoding[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72,
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65,
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    int32 length = 128;
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    expected.value = &length;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_operation_policy_name(void)
{
    uint8 expected[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x15,
        0x4F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
        0x6E, 0x20, 0x50, 0x6F, 0x6C, 0x69, 0x63, 0x79,
        0x20, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x07,
        0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x00
    };
    
    uint8 observed[56] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string policy = {0};
    policy.value = "default";
    policy.size = 7;
    
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_OPERATION_POLICY_NAME;
    attr.value = &policy;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_operation_policy_name(void)
{
    uint8 encoding[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x15,
        0x4F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F,
        0x6E, 0x20, 0x50, 0x6F, 0x6C, 0x69, 0x63, 0x79,
        0x20, 0x4E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x07,
        0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string policy = {0};
    policy.value = "default";
    policy.size = 7;
    
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_OPERATION_POLICY_NAME;
    expected.value = &policy;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_cryptographic_usage_mask(void)
{
    uint8 expected[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72,
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73,
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B,
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[56] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    int32 mask = KMIP_CRYPTOMASK_ENCRYPT | KMIP_CRYPTOMASK_DECRYPT;
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_CRYPTOGRAPHIC_USAGE_MASK;
    attr.value = &mask;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_cryptographic_usage_mask(void)
{
    uint8 encoding[56] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72,
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73,
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B,
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    int32 mask = KMIP_CRYPTOMASK_ENCRYPT | KMIP_CRYPTOMASK_DECRYPT;
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_CRYPTOGRAPHIC_USAGE_MASK;
    expected.value = &mask;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attribute_state(void)
{
    uint8 expected[40] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x05, 
        0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[40] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    enum state s = KMIP_STATE_PRE_ACTIVE;
    struct attribute attr = {0};
    init_attribute(&attr);
    
    attr.type = KMIP_ATTR_STATE;
    attr.value = &s;
    
    int result = encode_attribute(&ctx, &attr);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attribute_state(void)
{
    uint8 encoding[40] = {
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x05, 
        0x53, 0x74, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    enum state s = KMIP_STATE_PRE_ACTIVE;
    struct attribute expected = {0};
    init_attribute(&expected);
    expected.type = KMIP_ATTR_STATE;
    expected.value = &s;
    struct attribute observed = {0};
    init_attribute(&observed);
    
    int result = decode_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attribute(&expected, &observed),
        result,
        __func__);
    free_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_protocol_version(void)
{
    uint8 expected[40] = {
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[40] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    int result = encode_protocol_version(&ctx, &pv);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_protocol_version(void)
{
    uint8 encoding[40] = {
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct protocol_version expected = {0};
    expected.major = 1;
    expected.minor = 0;
    struct protocol_version observed = {0};
    
    int result = decode_protocol_version(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_protocol_version(&expected, &observed),
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_cryptographic_parameters(void)
{
    uint8 expected[72] = {
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x40,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x5F, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x38, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x83, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[72] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_CBC;
    cp.padding_method = KMIP_PAD_PKCS5;
    cp.hashing_algorithm = KMIP_HASH_SHA1;
    cp.key_role_type = KMIP_ROLE_KEK;
    
    int result = encode_cryptographic_parameters(&ctx, &cp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_cryptographic_parameters(void)
{
    uint8 encoding[72] = {
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x40,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x5F, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x38, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x83, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct cryptographic_parameters expected = {0};
    init_cryptographic_parameters(&expected);
    expected.block_cipher_mode = KMIP_BLOCK_CBC;
    expected.padding_method = KMIP_PAD_PKCS5;
    expected.hashing_algorithm = KMIP_HASH_SHA1;
    expected.key_role_type = KMIP_ROLE_KEK;
    struct cryptographic_parameters observed = {0};
    init_cryptographic_parameters(&observed);
    
    int result = decode_cryptographic_parameters(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_cryptographic_parameters(&expected, &observed),
        result,
        __func__);
    free_cryptographic_parameters(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_encryption_key_information(void)
{
    uint8 expected[80] = {
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48,
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D,
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[80] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    int result = encode_encryption_key_information(&ctx, &eki);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_encryption_key_information(void)
{
    uint8 encoding[80] = {
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48,
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D,
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    init_cryptographic_parameters(&cp);
    
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information expected = {0};
    expected.unique_identifier = &uuid;
    expected.cryptographic_parameters = &cp;
    
    struct encryption_key_information observed = {0};
    
    int result = decode_encryption_key_information(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_encryption_key_information(&expected, &observed),
        result,
        __func__);
    free_encryption_key_information(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_mac_signature_key_information(void)
{
    uint8 expected[80] = {
        0x42, 0x00, 0x4E, 0x01, 0x00, 0x00, 0x00, 0x48,
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D,
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[80] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;

    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;

    struct mac_signature_key_information mski = {0};
    mski.unique_identifier = &uuid;
    mski.cryptographic_parameters = &cp;
    
    int result = encode_mac_signature_key_information(&ctx, &mski);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_mac_signature_key_information(void)
{
    uint8 encoding[80] = {
        0x42, 0x00, 0x4E, 0x01, 0x00, 0x00, 0x00, 0x48,
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D,
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;

    struct cryptographic_parameters cp = {0};
    init_cryptographic_parameters(&cp);
    
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;

    struct mac_signature_key_information expected = {0};
    expected.unique_identifier = &uuid;
    expected.cryptographic_parameters = &cp;
    
    struct mac_signature_key_information observed = {0};
    
    int result = decode_mac_signature_key_information(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_mac_signature_key_information(&expected, &observed),
        result,
        __func__);
    free_mac_signature_key_information(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_wrapping_data(void)
{
    uint8 expected[104] = {
        0x42, 0x00, 0x46, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[104] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_data kwd = {0};
    kwd.wrapping_method = KMIP_WRAP_ENCRYPT;
    kwd.encryption_key_info = &eki;
    
    int result = encode_key_wrapping_data(&ctx, &kwd);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_wrapping_data(void)
{
    uint8 encoding[104] = {
        0x42, 0x00, 0x46, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    init_cryptographic_parameters(&cp);
    
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_data expected = {0};
    expected.wrapping_method = KMIP_WRAP_ENCRYPT;
    expected.encryption_key_info = &eki;
    
    struct key_wrapping_data observed = {0};
    
    int result = decode_key_wrapping_data(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_key_wrapping_data(&expected, &observed),
        result,
        __func__);
    free_key_wrapping_data(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_material_byte_string(void)
{
    uint8 expected[24] = {
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10,
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    
    uint8 observed[24] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    int result = encode_key_material(&ctx, KMIP_KEYFORMAT_RAW, &key);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_material_byte_string(void)
{
    uint8 encoding[24] = {
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10,
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    struct byte_string expected = {0};
    expected.value = value;
    expected.size = ARRAY_LENGTH(value);
    
    struct byte_string *expected_ptr = &expected;
    struct byte_string *observed_ptr = NULL;
    
    int result = decode_key_material(
        &ctx,
        KMIP_KEYFORMAT_RAW,
        (void**)&observed_ptr);
    result = report_decoding_test_result(
        &ctx,
        compare_key_material(KMIP_KEYFORMAT_RAW,
                             (void**)&expected_ptr,
                             (void**)&observed_ptr),
        result,
        __func__);
    free_key_material(&ctx, KMIP_KEYFORMAT_RAW, (void**)&observed_ptr);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_material_transparent_symmetric_key(void)
{
    uint8 expected[48] = {
        0x42, 0x00, 0x43, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x3F, 0x08, 0x00, 0x00, 0x00, 0x20, 
        0x00, 0x00, 0x11, 0x11, 0x22, 0x22, 0x33, 0x33, 
        0x44, 0x44, 0x55, 0x55, 0x66, 0x66, 0x77, 0x77,
        0x88, 0x88, 0x99, 0x99, 0xAA, 0xAA, 0xBB, 0xBB,
        0xCC, 0xCC, 0xDD, 0xDD, 0xEE, 0xEE, 0xFF, 0xFF
    };
    
    uint8 observed[48] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[32] = {
        0x00, 0x00, 0x11, 0x11, 0x22, 0x22, 0x33, 0x33, 
        0x44, 0x44, 0x55, 0x55, 0x66, 0x66, 0x77, 0x77,
        0x88, 0x88, 0x99, 0x99, 0xAA, 0xAA, 0xBB, 0xBB,
        0xCC, 0xCC, 0xDD, 0xDD, 0xEE, 0xEE, 0xFF, 0xFF
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    struct transparent_symmetric_key tsk = {0};
    tsk.key = &key;
    
    int result = encode_key_material(
        &ctx,
        KMIP_KEYFORMAT_TRANS_SYMMETRIC_KEY,
        &tsk);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_material_transparent_symmetric_key(void)
{
    uint8 encoding[48] = {
        0x42, 0x00, 0x43, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x3F, 0x08, 0x00, 0x00, 0x00, 0x20, 
        0x00, 0x00, 0x11, 0x11, 0x22, 0x22, 0x33, 0x33, 
        0x44, 0x44, 0x55, 0x55, 0x66, 0x66, 0x77, 0x77,
        0x88, 0x88, 0x99, 0x99, 0xAA, 0xAA, 0xBB, 0xBB,
        0xCC, 0xCC, 0xDD, 0xDD, 0xEE, 0xEE, 0xFF, 0xFF
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[32] = {
        0x00, 0x00, 0x11, 0x11, 0x22, 0x22, 0x33, 0x33, 
        0x44, 0x44, 0x55, 0x55, 0x66, 0x66, 0x77, 0x77,
        0x88, 0x88, 0x99, 0x99, 0xAA, 0xAA, 0xBB, 0xBB,
        0xCC, 0xCC, 0xDD, 0xDD, 0xEE, 0xEE, 0xFF, 0xFF
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    struct transparent_symmetric_key expected = {0};
    expected.key = &key;
    
    struct transparent_symmetric_key *expected_ptr = &expected;
    struct transparent_symmetric_key *observed_ptr = NULL;
    
    int result = decode_key_material(
        &ctx,
        KMIP_KEYFORMAT_TRANS_SYMMETRIC_KEY,
        (void**)&observed_ptr);
    result = report_decoding_test_result(
        &ctx,
        compare_key_material(KMIP_KEYFORMAT_TRANS_SYMMETRIC_KEY,
                             (void**)&expected_ptr,
                             (void**)&observed_ptr),
        result,
        __func__);
    free_key_material(
        &ctx,
        KMIP_KEYFORMAT_TRANS_SYMMETRIC_KEY,
        (void**)&observed_ptr);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_value(void)
{
    uint8 expected[32] = {
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x18,
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10,
        0xD3, 0x51, 0x91, 0x0F, 0x1D, 0x79, 0x34, 0xD6,
        0xE2, 0xAE, 0x17, 0x57, 0x65, 0x64, 0xE2, 0xBC
    };
    
    uint8 observed[32] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[16] = {
        0xD3, 0x51, 0x91, 0x0F, 0x1D, 0x79, 0x34, 0xD6,
        0xE2, 0xAE, 0x17, 0x57, 0x65, 0x64, 0xE2, 0xBC
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    int result = encode_key_value(
        &ctx,
        KMIP_KEYFORMAT_RAW,
        &kv);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_value(void)
{
    uint8 encoding[32] = {
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x18,
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10,
        0xD3, 0x51, 0x91, 0x0F, 0x1D, 0x79, 0x34, 0xD6,
        0xE2, 0xAE, 0x17, 0x57, 0x65, 0x64, 0xE2, 0xBC
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[16] = {
        0xD3, 0x51, 0x91, 0x0F, 0x1D, 0x79, 0x34, 0xD6,
        0xE2, 0xAE, 0x17, 0x57, 0x65, 0x64, 0xE2, 0xBC
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value expected = {0};
    expected.key_material = &key;
    struct key_value observed = {0};
    
    int result = decode_key_value(
        &ctx,
        KMIP_KEYFORMAT_RAW,
        &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_key_value(KMIP_KEYFORMAT_RAW, &expected, &observed),
        result,
        __func__);
    free_key_value(&ctx, KMIP_KEYFORMAT_RAW, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_value_with_attributes(void)
{
    uint8 expected[144] = {
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x88, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10, 
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[144] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct attribute attributes[2] = {0};
    for(int i = 0; i < 2; i++)
    {
        init_attribute(&attributes[i]);
    }
    
    enum cryptographic_algorithm ca = KMIP_CRYPTOALG_AES;
    int length = 128;
    attributes[0].type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    attributes[0].value = &ca;
    attributes[1].type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    attributes[1].value = &length;
    
    struct key_value kv = {0};
    kv.key_material = &key;
    kv.attributes = attributes;
    kv.attribute_count = ARRAY_LENGTH(attributes);
    
    int result = encode_key_value(
        &ctx,
        KMIP_KEYFORMAT_RAW,
        &kv);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_value_with_attributes(void)
{
    uint8 encoding[144] = {
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x88, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10, 
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14,
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct attribute attributes[2] = {0};
    for(size_t i = 0; i < 2; i++)
    {
        init_attribute(&attributes[i]);
    }
    
    enum cryptographic_algorithm ca = KMIP_CRYPTOALG_AES;
    int length = 128;
    attributes[0].type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    attributes[0].value = &ca;
    attributes[1].type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    attributes[1].value = &length;
    
    struct key_value expected = {0};
    expected.key_material = &key;
    expected.attributes = attributes;
    expected.attribute_count = ARRAY_LENGTH(attributes);
    struct key_value observed = {0};
    
    int result = decode_key_value(
        &ctx,
        KMIP_KEYFORMAT_RAW,
        &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_key_value(KMIP_KEYFORMAT_RAW, &expected, &observed),
        result,
        __func__);
    free_key_value(&ctx, KMIP_KEYFORMAT_RAW, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_block_key_value_byte_string(void)
{
    uint8 expected[192] = {
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0xB8, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x1F, 0xA6, 0x8B, 0x0A, 0x81, 0x12, 0xB4, 0x47, 
        0xAE, 0xF3, 0x4B, 0xD8, 0xFB, 0x5A, 0x7B, 0x82, 
        0x9D, 0x3E, 0x86, 0x23, 0x71, 0xD2, 0xCF, 0xE5, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x46, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35, 
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[192] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[24] = {
        0x1F, 0xA6, 0x8B, 0x0A, 0x81, 0x12, 0xB4, 0x47,
        0xAE, 0xF3, 0x4B, 0xD8, 0xFB, 0x5A, 0x7B, 0x82,
        0x9D, 0x3E, 0x86, 0x23, 0x71, 0xD2, 0xCF, 0xE5
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_data kwd = {0};
    kwd.wrapping_method = KMIP_WRAP_ENCRYPT;
    kwd.encryption_key_info = &eki;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &key;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_AES;
    kb.cryptographic_length = 128;
    kb.key_wrapping_data = &kwd;
    
    int result = encode_key_block(&ctx, &kb);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_block_key_value_byte_string(void)
{
    uint8 encoding[192] = {
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0xB8, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x1F, 0xA6, 0x8B, 0x0A, 0x81, 0x12, 0xB4, 0x47, 
        0xAE, 0xF3, 0x4B, 0xD8, 0xFB, 0x5A, 0x7B, 0x82, 
        0x9D, 0x3E, 0x86, 0x23, 0x71, 0xD2, 0xCF, 0xE5, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x46, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24,
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35, 
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[24] = {
        0x1F, 0xA6, 0x8B, 0x0A, 0x81, 0x12, 0xB4, 0x47,
        0xAE, 0xF3, 0x4B, 0xD8, 0xFB, 0x5A, 0x7B, 0x82,
        0x9D, 0x3E, 0x86, 0x23, 0x71, 0xD2, 0xCF, 0xE5
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    init_cryptographic_parameters(&cp);
    
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_data kwd = {0};
    kwd.wrapping_method = KMIP_WRAP_ENCRYPT;
    kwd.encryption_key_info = &eki;
    
    struct key_block expected = {0};
    init_key_block(&expected);
    
    expected.key_format_type = KMIP_KEYFORMAT_RAW;
    expected.key_value = &key;
    expected.key_value_type = KMIP_TYPE_BYTE_STRING;
    expected.cryptographic_algorithm = KMIP_CRYPTOALG_AES;
    expected.cryptographic_length = 128;
    expected.key_wrapping_data = &kwd;
    
    struct key_block observed = {0};
    init_key_block(&observed);
    
    int result = decode_key_block(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_key_block(&expected, &observed),
        result,
        __func__);
    free_key_block(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_block_key_value_structure(void)
{
    uint8 expected[88] = {
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x50, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x18, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10, 
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[88] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_AES;
    kb.cryptographic_length = 128;
    
    int result = encode_key_block(&ctx, &kb);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_block_key_value_structure(void)
{
    uint8 encoding[88] = {
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x50, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x18, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10, 
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block expected = {0};
    init_key_block(&expected);
    
    expected.key_format_type = KMIP_KEYFORMAT_RAW;
    expected.key_value = &kv;
    expected.key_value_type = KMIP_TYPE_STRUCTURE;
    expected.cryptographic_algorithm = KMIP_CRYPTOALG_AES;
    expected.cryptographic_length = 128;
    
    struct key_block observed = {0};
    init_key_block(&observed);
    
    int result = decode_key_block(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_key_block(&expected, &observed),
        result,
        __func__);
    free_key_block(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_symmetric_key(void)
{
    uint8 expected[96] = {
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x50, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x18, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10, 
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[96] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_AES;
    kb.cryptographic_length = 128;
    
    struct symmetric_key sk = {0};
    sk.key_block = &kb;
    
    int result = encode_symmetric_key(&ctx, &sk);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_symmetric_key(void)
{
    uint8 encoding[96] = {
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x50, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x18, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x10, 
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[16] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.key_value_type = KMIP_TYPE_STRUCTURE;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_AES;
    kb.cryptographic_length = 128;
    
    struct symmetric_key expected = {0};
    expected.key_block = &kb;
    
    struct symmetric_key observed = {0};
    
    int result = decode_symmetric_key(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_symmetric_key(&expected, &observed),
        result,
        __func__);
    free_symmetric_key(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_public_key(void)
{
    uint8 expected[248] = {
        0x42, 0x00, 0x6D, 0x01, 0x00, 0x00, 0x00, 0xF0, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0xE8, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0xB0, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0xA2,
        0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A,
        0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 
        0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81, 
        0x89, 0x02, 0x81, 0x81, 0x00, 0x93, 0x04, 0x51,
        0xC9, 0xEC, 0xD9, 0x4F, 0x5B, 0xB9, 0xDA, 0x17, 
        0xDD, 0x09, 0x38, 0x1B, 0xD2, 0x3B, 0xE4, 0x3E, 
        0xCA, 0x8C, 0x75, 0x39, 0xF3, 0x01, 0xFC, 0x8A, 
        0x8C, 0xD5, 0xD5, 0x27, 0x4C, 0x3E, 0x76, 0x99, 
        0xDB, 0xDC, 0x71, 0x1C, 0x97, 0xA7, 0xAA, 0x91, 
        0xE2, 0xC5, 0x0A, 0x82, 0xBD, 0x0B, 0x10, 0x34, 
        0xF0, 0xDF, 0x49, 0x3D, 0xEC, 0x16, 0x36, 0x24,
        0x27, 0xE5, 0x8A, 0xCC, 0xE7, 0xF6, 0xCE, 0x0F, 
        0x9B, 0xCC, 0x61, 0x7B, 0xBD, 0x8C, 0x90, 0xD0, 
        0x09, 0x4A, 0x27, 0x03, 0xBA, 0x0D, 0x09, 0xEB, 
        0x19, 0xD1, 0x00, 0x5F, 0x2F, 0xB2, 0x65, 0x52, 
        0x6A, 0xAC, 0x75, 0xAF, 0x32, 0xF8, 0xBC, 0x78, 
        0x2C, 0xDE, 0xD2, 0xA5, 0x7F, 0x81, 0x1E, 0x03,
        0xEA, 0xF6, 0x7A, 0x94, 0x4D, 0xE5, 0xE7, 0x84, 
        0x13, 0xDC, 0xA8, 0xF2, 0x32, 0xD0, 0x74, 0xE6,
        0xDC, 0xEA, 0x4C, 0xEC, 0x9F, 0x02, 0x03, 0x01, 
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[248] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[162] = {
        0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 
        0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 
        0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81, 
        0x89, 0x02, 0x81, 0x81, 0x00, 0x93, 0x04, 0x51,
        0xC9, 0xEC, 0xD9, 0x4F, 0x5B, 0xB9, 0xDA, 0x17, 
        0xDD, 0x09, 0x38, 0x1B, 0xD2, 0x3B, 0xE4, 0x3E, 
        0xCA, 0x8C, 0x75, 0x39, 0xF3, 0x01, 0xFC, 0x8A, 
        0x8C, 0xD5, 0xD5, 0x27, 0x4C, 0x3E, 0x76, 0x99,
        0xDB, 0xDC, 0x71, 0x1C, 0x97, 0xA7, 0xAA, 0x91, 
        0xE2, 0xC5, 0x0A, 0x82, 0xBD, 0x0B, 0x10, 0x34, 
        0xF0, 0xDF, 0x49, 0x3D, 0xEC, 0x16, 0x36, 0x24, 
        0x27, 0xE5, 0x8A, 0xCC, 0xE7, 0xF6, 0xCE, 0x0F, 
        0x9B, 0xCC, 0x61, 0x7B, 0xBD, 0x8C, 0x90, 0xD0, 
        0x09, 0x4A, 0x27, 0x03, 0xBA, 0x0D, 0x09, 0xEB, 
        0x19, 0xD1, 0x00, 0x5F, 0x2F, 0xB2, 0x65, 0x52, 
        0x6A, 0xAC, 0x75, 0xAF, 0x32, 0xF8, 0xBC, 0x78, 
        0x2C, 0xDE, 0xD2, 0xA5, 0x7F, 0x81, 0x1E, 0x03, 
        0xEA, 0xF6, 0x7A, 0x94, 0x4D, 0xE5, 0xE7, 0x84,
        0x13, 0xDC, 0xA8, 0xF2, 0x32, 0xD0, 0x74, 0xE6,
        0xDC, 0xEA, 0x4C, 0xEC, 0x9F, 0x02, 0x03, 0x01,
        0x00, 0x01
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_X509;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    kb.cryptographic_length = 1024;
    
    struct public_key pk = {0};
    pk.key_block = &kb;
    
    int result = encode_public_key(&ctx, &pk);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_public_key(void)
{
    uint8 encoding[248] = {
        0x42, 0x00, 0x6D, 0x01, 0x00, 0x00, 0x00, 0xF0, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0xE8, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0xB0, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0xA2,
        0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A,
        0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 
        0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81, 
        0x89, 0x02, 0x81, 0x81, 0x00, 0x93, 0x04, 0x51,
        0xC9, 0xEC, 0xD9, 0x4F, 0x5B, 0xB9, 0xDA, 0x17, 
        0xDD, 0x09, 0x38, 0x1B, 0xD2, 0x3B, 0xE4, 0x3E, 
        0xCA, 0x8C, 0x75, 0x39, 0xF3, 0x01, 0xFC, 0x8A, 
        0x8C, 0xD5, 0xD5, 0x27, 0x4C, 0x3E, 0x76, 0x99, 
        0xDB, 0xDC, 0x71, 0x1C, 0x97, 0xA7, 0xAA, 0x91, 
        0xE2, 0xC5, 0x0A, 0x82, 0xBD, 0x0B, 0x10, 0x34, 
        0xF0, 0xDF, 0x49, 0x3D, 0xEC, 0x16, 0x36, 0x24,
        0x27, 0xE5, 0x8A, 0xCC, 0xE7, 0xF6, 0xCE, 0x0F, 
        0x9B, 0xCC, 0x61, 0x7B, 0xBD, 0x8C, 0x90, 0xD0, 
        0x09, 0x4A, 0x27, 0x03, 0xBA, 0x0D, 0x09, 0xEB, 
        0x19, 0xD1, 0x00, 0x5F, 0x2F, 0xB2, 0x65, 0x52, 
        0x6A, 0xAC, 0x75, 0xAF, 0x32, 0xF8, 0xBC, 0x78, 
        0x2C, 0xDE, 0xD2, 0xA5, 0x7F, 0x81, 0x1E, 0x03,
        0xEA, 0xF6, 0x7A, 0x94, 0x4D, 0xE5, 0xE7, 0x84, 
        0x13, 0xDC, 0xA8, 0xF2, 0x32, 0xD0, 0x74, 0xE6,
        0xDC, 0xEA, 0x4C, 0xEC, 0x9F, 0x02, 0x03, 0x01, 
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[162] = {
        0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 
        0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 
        0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81, 
        0x89, 0x02, 0x81, 0x81, 0x00, 0x93, 0x04, 0x51,
        0xC9, 0xEC, 0xD9, 0x4F, 0x5B, 0xB9, 0xDA, 0x17, 
        0xDD, 0x09, 0x38, 0x1B, 0xD2, 0x3B, 0xE4, 0x3E, 
        0xCA, 0x8C, 0x75, 0x39, 0xF3, 0x01, 0xFC, 0x8A, 
        0x8C, 0xD5, 0xD5, 0x27, 0x4C, 0x3E, 0x76, 0x99,
        0xDB, 0xDC, 0x71, 0x1C, 0x97, 0xA7, 0xAA, 0x91, 
        0xE2, 0xC5, 0x0A, 0x82, 0xBD, 0x0B, 0x10, 0x34, 
        0xF0, 0xDF, 0x49, 0x3D, 0xEC, 0x16, 0x36, 0x24, 
        0x27, 0xE5, 0x8A, 0xCC, 0xE7, 0xF6, 0xCE, 0x0F, 
        0x9B, 0xCC, 0x61, 0x7B, 0xBD, 0x8C, 0x90, 0xD0, 
        0x09, 0x4A, 0x27, 0x03, 0xBA, 0x0D, 0x09, 0xEB, 
        0x19, 0xD1, 0x00, 0x5F, 0x2F, 0xB2, 0x65, 0x52, 
        0x6A, 0xAC, 0x75, 0xAF, 0x32, 0xF8, 0xBC, 0x78, 
        0x2C, 0xDE, 0xD2, 0xA5, 0x7F, 0x81, 0x1E, 0x03, 
        0xEA, 0xF6, 0x7A, 0x94, 0x4D, 0xE5, 0xE7, 0x84,
        0x13, 0xDC, 0xA8, 0xF2, 0x32, 0xD0, 0x74, 0xE6,
        0xDC, 0xEA, 0x4C, 0xEC, 0x9F, 0x02, 0x03, 0x01,
        0x00, 0x01
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_X509;
    kb.key_value = &kv;
    kb.key_value_type = KMIP_TYPE_STRUCTURE;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    kb.cryptographic_length = 1024;
    
    struct public_key expected = {0};
    expected.key_block = &kb;
    
    struct public_key observed = {0};
    
    int result = decode_public_key(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_public_key(&expected, &observed),
        result,
        __func__);
    free_public_key(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_private_key(void)
{
    uint8 expected[1280] = {
        0x42, 0x00, 0x64, 0x01, 0x00, 0x00, 0x04, 0xF8, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x04, 0xF0, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x04, 0xB8, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x04, 0xA9,
        0x30, 0x82, 0x04, 0xA5, 0x02, 0x01, 0x00, 0x02, 
        0x82, 0x01, 0x01, 0x00, 0xAB, 0x7F, 0x16, 0x1C, 
        0x00, 0x42, 0x49, 0x6C, 0xCD, 0x6C, 0x6D, 0x4D, 
        0xAD, 0xB9, 0x19, 0x97, 0x34, 0x35, 0x35, 0x77, 
        0x76, 0x00, 0x3A, 0xCF, 0x54, 0xB7, 0xAF, 0x1E, 
        0x44, 0x0A, 0xFB, 0x80, 0xB6, 0x4A, 0x87, 0x55, 
        0xF8, 0x00, 0x2C, 0xFE, 0xBA, 0x6B, 0x18, 0x45, 
        0x40, 0xA2, 0xD6, 0x60, 0x86, 0xD7, 0x46, 0x48, 
        0x34, 0x6D, 0x75, 0xB8, 0xD7, 0x18, 0x12, 0xB2, 
        0x05, 0x38, 0x7C, 0x0F, 0x65, 0x83, 0xBC, 0x4D, 
        0x7D, 0xC7, 0xEC, 0x11, 0x4F, 0x3B, 0x17, 0x6B, 
        0x79, 0x57, 0xC4, 0x22, 0xE7, 0xD0, 0x3F, 0xC6,
        0x26, 0x7F, 0xA2, 0xA6, 0xF8, 0x9B, 0x9B, 0xEE, 
        0x9E, 0x60, 0xA1, 0xD7, 0xC2, 0xD8, 0x33, 0xE5, 
        0xA5, 0xF4, 0xBB, 0x0B, 0x14, 0x34, 0xF4, 0xE7, 
        0x95, 0xA4, 0x11, 0x00, 0xF8, 0xAA, 0x21, 0x49, 
        0x00, 0xDF, 0x8B, 0x65, 0x08, 0x9F, 0x98, 0x13, 
        0x5B, 0x1C, 0x67, 0xB7, 0x01, 0x67, 0x5A, 0xBD, 
        0xBC, 0x7D, 0x57, 0x21, 0xAA, 0xC9, 0xD1, 0x4A, 
        0x7F, 0x08, 0x1F, 0xCE, 0xC8, 0x0B, 0x64, 0xE8, 
        0xA0, 0xEC, 0xC8, 0x29, 0x53, 0x53, 0xC7, 0x95, 
        0x32, 0x8A, 0xBF, 0x70, 0xE1, 0xB4, 0x2E, 0x7B, 
        0xB8, 0xB7, 0xF4, 0xE8, 0xAC, 0x8C, 0x81, 0x0C, 
        0xDB, 0x66, 0xE3, 0xD2, 0x11, 0x26, 0xEB, 0xA8, 
        0xDA, 0x7D, 0x0C, 0xA3, 0x41, 0x42, 0xCB, 0x76, 
        0xF9, 0x1F, 0x01, 0x3D, 0xA8, 0x09, 0xE9, 0xC1, 
        0xB7, 0xAE, 0x64, 0xC5, 0x41, 0x30, 0xFB, 0xC2, 
        0x1D, 0x80, 0xE9, 0xC2, 0xCB, 0x06, 0xC5, 0xC8, 
        0xD7, 0xCC, 0xE8, 0x94, 0x6A, 0x9A, 0xC9, 0x9B,
        0x1C, 0x28, 0x15, 0xC3, 0x61, 0x2A, 0x29, 0xA8, 
        0x2D, 0x73, 0xA1, 0xF9, 0x93, 0x74, 0xFE, 0x30, 
        0xE5, 0x49, 0x51, 0x66, 0x2A, 0x6E, 0xDA, 0x29, 
        0xC6, 0xFC, 0x41, 0x13, 0x35, 0xD5, 0xDC, 0x74, 
        0x26, 0xB0, 0xF6, 0x05, 0x02, 0x03, 0x01, 0x00, 
        0x01, 0x02, 0x82, 0x01, 0x00, 0x3B, 0x12, 0x45, 
        0x5D, 0x53, 0xC1, 0x81, 0x65, 0x16, 0xC5, 0x18, 
        0x49, 0x3F, 0x63, 0x98, 0xAA, 0xFA, 0x72, 0xB1, 
        0x7D, 0xFA, 0x89, 0x4D, 0xB8, 0x88, 0xA7, 0xD4, 
        0x8C, 0x0A, 0x47, 0xF6, 0x25, 0x79, 0xA4, 0xE6, 
        0x44, 0xF8, 0x6D, 0xA7, 0x11, 0xFE, 0xC8, 0x50, 
        0xCD, 0xD9, 0xDB, 0xBD, 0x17, 0xF6, 0x9A, 0x44, 
        0x3D, 0x2E, 0xC1, 0xDD, 0x60, 0xD3, 0xC6, 0x18, 
        0xFA, 0x74, 0xCD, 0xE5, 0xFD, 0xAF, 0xAB, 0xD6, 
        0xBA, 0xA2, 0x6E, 0xB0, 0xA3, 0xAD, 0xB4, 0xDE, 
        0xF6, 0x48, 0x0F, 0xB1, 0x21, 0x8C, 0xD3, 0xB0,
        0x83, 0xE2, 0x52, 0xE8, 0x85, 0xB6, 0xF0, 0x72, 
        0x9F, 0x98, 0xB2, 0x14, 0x4D, 0x2B, 0x72, 0x29, 
        0x3E, 0x1B, 0x11, 0xD7, 0x33, 0x93, 0xBC, 0x41, 
        0xF7, 0x5B, 0x15, 0xEE, 0x3D, 0x75, 0x69, 0xB4, 
        0x99, 0x5E, 0xD1, 0xA1, 0x44, 0x25, 0xDA, 0x43, 
        0x19, 0xB7, 0xB2, 0x6B, 0x0E, 0x8F, 0xEF, 0x17, 
        0xC3, 0x75, 0x42, 0xAE, 0x5C, 0x6D, 0x58, 0x49, 
        0xF8, 0x72, 0x09, 0x56, 0x7F, 0x39, 0x25, 0xA4, 
        0x7B, 0x01, 0x6D, 0x56, 0x48, 0x59, 0x71, 0x7B, 
        0xC5, 0x7F, 0xCB, 0x45, 0x22, 0xD0, 0xAA, 0x49, 
        0xCE, 0x81, 0x6E, 0x5B, 0xE7, 0xB3, 0x08, 0x81, 
        0x93, 0x23, 0x6E, 0xC9, 0xEF, 0xFF, 0x14, 0x08, 
        0x58, 0x04, 0x5B, 0x73, 0xC5, 0xD7, 0x9B, 0xAF, 
        0x38, 0xF7, 0xC6, 0x7F, 0x04, 0xC5, 0xDC, 0xF0, 
        0xE3, 0x80, 0x6A, 0xD9, 0x82, 0xD1, 0x25, 0x90, 
        0x58, 0xC3, 0x47, 0x3E, 0x84, 0x71, 0x79, 0xA8, 
        0x78, 0xF2, 0xC6, 0xB3, 0xBD, 0x96, 0x8F, 0xB9,
        0x9E, 0xA4, 0x6E, 0x91, 0x85, 0x89, 0x2F, 0x36,
        0x76, 0xE7, 0x89, 0x65, 0xC2, 0xAE, 0xD4, 0x87,
        0x7B, 0xA3, 0x91, 0x7D, 0xF0, 0x7C, 0x5E, 0x92, 
        0x74, 0x74, 0xF1, 0x9E, 0x76, 0x4B, 0xA6, 0x1D, 
        0xC3, 0x8D, 0x63, 0xBF, 0x29, 0x02, 0x81, 0x81, 
        0x00, 0xD5, 0xC6, 0x9C, 0x8C, 0x3C, 0xDC, 0x24, 
        0x64, 0x74, 0x4A, 0x79, 0x37, 0x13, 0xDA, 0xFB, 
        0x9F, 0x1D, 0xBC, 0x79, 0x9F, 0xF9, 0x64, 0x23, 
        0xFE, 0xCD, 0x3C, 0xBA, 0x79, 0x42, 0x86, 0xBC, 
        0xE9, 0x20, 0xF4, 0xB5, 0xC1, 0x83, 0xF9, 0x9E, 
        0xE9, 0x02, 0x8D, 0xB6, 0x21, 0x2C, 0x62, 0x77, 
        0xC4, 0xC8, 0x29, 0x7F, 0xCF, 0xBC, 0xE7, 0xF7,
        0xC2, 0x4C, 0xA4, 0xC5, 0x1F, 0xC7, 0x18, 0x2F, 
        0xB8, 0xF4, 0x01, 0x9F, 0xB1, 0xD5, 0x65, 0x96, 
        0x74, 0xC5, 0xCB, 0xE6, 0xD5, 0xFA, 0x99, 0x20, 
        0x51, 0x34, 0x17, 0x60, 0xCD, 0x00, 0x73, 0x57, 
        0x29, 0xA0, 0x70, 0xA9, 0xE5, 0x4D, 0x34, 0x2B, 
        0xEB, 0xA8, 0xEF, 0x47, 0xEE, 0x82, 0xD3, 0xA0, 
        0x1B, 0x04, 0xCE, 0xC4, 0xA0, 0x0D, 0x4D, 0xDB,
        0x41, 0xE3, 0x51, 0x16, 0xFC, 0x22, 0x1E, 0x85, 
        0x4B, 0x43, 0xA6, 0x96, 0xC0, 0xE6, 0x41, 0x9B, 
        0x1B, 0x02, 0x81, 0x81, 0x00, 0xCD, 0x5E, 0xA7, 
        0x70, 0x27, 0x89, 0x06, 0x4B, 0x67, 0x35, 0x40, 
        0xCB, 0xFF, 0x09, 0x35, 0x6A, 0xD8, 0x0B, 0xC3, 
        0xD5, 0x92, 0x81, 0x2E, 0xBA, 0x47, 0x61, 0x0B,
        0x9F, 0xAC, 0x6A, 0xEC, 0xEF, 0xE2, 0x2A, 0xCA, 
        0xE4, 0x38, 0x45, 0x9C, 0xDA, 0x74, 0xE5, 0x96, 
        0x53, 0xD8, 0x8C, 0x04, 0x18, 0x9D, 0x34, 0x39, 
        0x9B, 0xF5, 0xB1, 0x4B, 0x92, 0x0E, 0x34, 0xEF, 
        0x38, 0xA7, 0xD0, 0x9F, 0xE6, 0x95, 0x93, 0x39, 
        0x6E, 0x8F, 0xE7, 0x35, 0xE6, 0xF0, 0xA6, 0xAE, 
        0x49, 0x90, 0x40, 0x10, 0x41, 0xD8, 0xA4, 0x06, 
        0xB6, 0xFD, 0x86, 0xA1, 0x16, 0x1E, 0x45, 0xF9,
        0x5A, 0x3E, 0xAA, 0x5C, 0x10, 0x12, 0xE6, 0x66,
        0x2E, 0x44, 0xF1, 0x5F, 0x33, 0x5A, 0xC9, 0x71, 
        0xE1, 0x76, 0x6B, 0x2B, 0xB9, 0xC9, 0x85, 0x10, 
        0x99, 0x74, 0x14, 0x1B, 0x44, 0xD3, 0x7E, 0x1E, 
        0x31, 0x98, 0x20, 0xA5, 0x5F, 0x02, 0x81, 0x81, 
        0x00, 0xB2, 0x87, 0x12, 0x37, 0xBF, 0x9F, 0xAD, 
        0x38, 0xC3, 0x31, 0x6A, 0xB7, 0x87, 0x7A, 0x6A, 
        0x86, 0x80, 0x63, 0xE5, 0x42, 0xA7, 0x18, 0x6D, 
        0x43, 0x1E, 0x8D, 0x27, 0xC1, 0x9A, 0xC0, 0x41, 
        0x45, 0x84, 0x03, 0x39, 0x42, 0xE9, 0xFF, 0x6E, 
        0x29, 0x73, 0xBB, 0x7B, 0x2D, 0x8B, 0x0E, 0x94, 
        0xAD, 0x1E, 0xE8, 0x21, 0x58, 0x10, 0x8F, 0xBC,
        0x86, 0x64, 0x51, 0x7A, 0x5A, 0x46, 0x7F, 0xB9, 
        0x63, 0x01, 0x4B, 0xD5, 0xDC, 0xC2, 0xB4, 0xFB, 
        0x08, 0x7C, 0x23, 0x03, 0x9D, 0x11, 0x92, 0x0D, 
        0xBE, 0x22, 0xFD, 0x9F, 0x16, 0xB4, 0xD8, 0x9E, 
        0x23, 0x22, 0x5C, 0xD4, 0x55, 0xAD, 0xBA, 0xF3, 
        0x2E, 0xF4, 0x3F, 0x18, 0x58, 0x64, 0xA3, 0x6D,
        0x63, 0x03, 0x09, 0xD6, 0x85, 0x3F, 0x77, 0x14,
        0xB3, 0x9A, 0xAE, 0x1E, 0xBE, 0xE3, 0x93, 0x8F, 
        0x87, 0xC2, 0x70, 0x7E, 0x17, 0x8C, 0x73, 0x9F, 
        0x9F, 0x02, 0x81, 0x81, 0x00, 0x96, 0x90, 0xBE,
        0xD1, 0x4B, 0x2A, 0xFA, 0xA2, 0x6D, 0x98, 0x6D, 
        0x59, 0x22, 0x31, 0xEE, 0x27, 0xD7, 0x1D, 0x49, 
        0x06, 0x5B, 0xD2, 0xBA, 0x1F, 0x78, 0x15, 0x7E, 
        0x20, 0x22, 0x98, 0x81, 0xFD, 0x9D, 0x23, 0x22, 
        0x7D, 0x0F, 0x84, 0x79, 0xEA, 0xEF, 0xA9, 0x22, 
        0xFD, 0x75, 0xD5, 0xB1, 0x6B, 0x1A, 0x56, 0x1F,
        0xA6, 0x68, 0x0B, 0x04, 0x0C, 0xA0, 0xBD, 0xCE, 
        0x65, 0x0B, 0x23, 0xB9, 0x17, 0xA4, 0xB1, 0xBB, 
        0x79, 0x83, 0xA7, 0x4F, 0xAD, 0x70, 0xE1, 0xC3, 
        0x05, 0xCB, 0xEC, 0x2B, 0xFF, 0x1A, 0x85, 0xA7,
        0x26, 0xA1, 0xD9, 0x02, 0x60, 0xE4, 0xF1, 0x08, 
        0x4F, 0x51, 0x82, 0x34, 0xDC, 0xD3, 0xFE, 0x77, 
        0x0B, 0x95, 0x20, 0x21, 0x5B, 0xD5, 0x43, 0xBB, 
        0x6A, 0x41, 0x17, 0x71, 0x87, 0x54, 0x67, 0x6A, 
        0x34, 0x17, 0x16, 0x66, 0xA7, 0x9F, 0x26, 0xE7, 
        0x9C, 0x14, 0x9C, 0x5A, 0xA1, 0x02, 0x81, 0x81, 
        0x00, 0xA0, 0xC9, 0x85, 0xA0, 0xA0, 0xA7, 0x91, 
        0xA6, 0x59, 0xF9, 0x97, 0x31, 0x13, 0x4C, 0x44, 
        0xF3, 0x7B, 0x2E, 0x52, 0x0A, 0x2C, 0xEA, 0x35, 
        0x80, 0x0A, 0xD2, 0x72, 0x41, 0xED, 0x36, 0x0D, 
        0xFD, 0xE6, 0xE8, 0xCA, 0x61, 0x4F, 0x12, 0x04, 
        0x7F, 0xD0, 0x8B, 0x76, 0xAC, 0x4D, 0x13, 0xC0, 
        0x56, 0xA0, 0x69, 0x9E, 0x2F, 0x98, 0xA1, 0xCA, 
        0xC9, 0x10, 0x11, 0x29, 0x4D, 0x71, 0x20, 0x8F, 
        0x4A, 0xBA, 0xB3, 0x3B, 0xA8, 0x7A, 0xA0, 0x51, 
        0x7F, 0x41, 0x5B, 0xAC, 0xA8, 0x8D, 0x6B, 0xAC, 
        0x00, 0x60, 0x88, 0xFA, 0x60, 0x1D, 0x34, 0x94, 
        0x17, 0xE1, 0xF0, 0xC9, 0xB2, 0x3A, 0xFF, 0xA4, 
        0xD4, 0x96, 0x61, 0x8D, 0xBC, 0x02, 0x49, 0x86, 
        0xED, 0x69, 0x0B, 0xBB, 0x7B, 0x02, 0x57, 0x68, 
        0xFF, 0x9D, 0xF8, 0xAC, 0x15, 0x41, 0x6F, 0x48, 
        0x9F, 0x81, 0x29, 0xC3, 0x23, 0x41, 0xA8, 0xB4, 
        0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[1280] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    uint8 value[1193] = {
        0x30, 0x82, 0x04, 0xA5, 0x02, 0x01, 0x00, 0x02, 
        0x82, 0x01, 0x01, 0x00, 0xAB, 0x7F, 0x16, 0x1C, 
        0x00, 0x42, 0x49, 0x6C, 0xCD, 0x6C, 0x6D, 0x4D, 
        0xAD, 0xB9, 0x19, 0x97, 0x34, 0x35, 0x35, 0x77, 
        0x76, 0x00, 0x3A, 0xCF, 0x54, 0xB7, 0xAF, 0x1E, 
        0x44, 0x0A, 0xFB, 0x80, 0xB6, 0x4A, 0x87, 0x55, 
        0xF8, 0x00, 0x2C, 0xFE, 0xBA, 0x6B, 0x18, 0x45, 
        0x40, 0xA2, 0xD6, 0x60, 0x86, 0xD7, 0x46, 0x48, 
        0x34, 0x6D, 0x75, 0xB8, 0xD7, 0x18, 0x12, 0xB2, 
        0x05, 0x38, 0x7C, 0x0F, 0x65, 0x83, 0xBC, 0x4D, 
        0x7D, 0xC7, 0xEC, 0x11, 0x4F, 0x3B, 0x17, 0x6B, 
        0x79, 0x57, 0xC4, 0x22, 0xE7, 0xD0, 0x3F, 0xC6,
        0x26, 0x7F, 0xA2, 0xA6, 0xF8, 0x9B, 0x9B, 0xEE, 
        0x9E, 0x60, 0xA1, 0xD7, 0xC2, 0xD8, 0x33, 0xE5, 
        0xA5, 0xF4, 0xBB, 0x0B, 0x14, 0x34, 0xF4, 0xE7, 
        0x95, 0xA4, 0x11, 0x00, 0xF8, 0xAA, 0x21, 0x49, 
        0x00, 0xDF, 0x8B, 0x65, 0x08, 0x9F, 0x98, 0x13, 
        0x5B, 0x1C, 0x67, 0xB7, 0x01, 0x67, 0x5A, 0xBD, 
        0xBC, 0x7D, 0x57, 0x21, 0xAA, 0xC9, 0xD1, 0x4A, 
        0x7F, 0x08, 0x1F, 0xCE, 0xC8, 0x0B, 0x64, 0xE8, 
        0xA0, 0xEC, 0xC8, 0x29, 0x53, 0x53, 0xC7, 0x95, 
        0x32, 0x8A, 0xBF, 0x70, 0xE1, 0xB4, 0x2E, 0x7B, 
        0xB8, 0xB7, 0xF4, 0xE8, 0xAC, 0x8C, 0x81, 0x0C, 
        0xDB, 0x66, 0xE3, 0xD2, 0x11, 0x26, 0xEB, 0xA8, 
        0xDA, 0x7D, 0x0C, 0xA3, 0x41, 0x42, 0xCB, 0x76, 
        0xF9, 0x1F, 0x01, 0x3D, 0xA8, 0x09, 0xE9, 0xC1, 
        0xB7, 0xAE, 0x64, 0xC5, 0x41, 0x30, 0xFB, 0xC2, 
        0x1D, 0x80, 0xE9, 0xC2, 0xCB, 0x06, 0xC5, 0xC8, 
        0xD7, 0xCC, 0xE8, 0x94, 0x6A, 0x9A, 0xC9, 0x9B,
        0x1C, 0x28, 0x15, 0xC3, 0x61, 0x2A, 0x29, 0xA8, 
        0x2D, 0x73, 0xA1, 0xF9, 0x93, 0x74, 0xFE, 0x30, 
        0xE5, 0x49, 0x51, 0x66, 0x2A, 0x6E, 0xDA, 0x29, 
        0xC6, 0xFC, 0x41, 0x13, 0x35, 0xD5, 0xDC, 0x74, 
        0x26, 0xB0, 0xF6, 0x05, 0x02, 0x03, 0x01, 0x00, 
        0x01, 0x02, 0x82, 0x01, 0x00, 0x3B, 0x12, 0x45, 
        0x5D, 0x53, 0xC1, 0x81, 0x65, 0x16, 0xC5, 0x18, 
        0x49, 0x3F, 0x63, 0x98, 0xAA, 0xFA, 0x72, 0xB1, 
        0x7D, 0xFA, 0x89, 0x4D, 0xB8, 0x88, 0xA7, 0xD4, 
        0x8C, 0x0A, 0x47, 0xF6, 0x25, 0x79, 0xA4, 0xE6, 
        0x44, 0xF8, 0x6D, 0xA7, 0x11, 0xFE, 0xC8, 0x50, 
        0xCD, 0xD9, 0xDB, 0xBD, 0x17, 0xF6, 0x9A, 0x44, 
        0x3D, 0x2E, 0xC1, 0xDD, 0x60, 0xD3, 0xC6, 0x18, 
        0xFA, 0x74, 0xCD, 0xE5, 0xFD, 0xAF, 0xAB, 0xD6, 
        0xBA, 0xA2, 0x6E, 0xB0, 0xA3, 0xAD, 0xB4, 0xDE, 
        0xF6, 0x48, 0x0F, 0xB1, 0x21, 0x8C, 0xD3, 0xB0,
        0x83, 0xE2, 0x52, 0xE8, 0x85, 0xB6, 0xF0, 0x72, 
        0x9F, 0x98, 0xB2, 0x14, 0x4D, 0x2B, 0x72, 0x29, 
        0x3E, 0x1B, 0x11, 0xD7, 0x33, 0x93, 0xBC, 0x41, 
        0xF7, 0x5B, 0x15, 0xEE, 0x3D, 0x75, 0x69, 0xB4, 
        0x99, 0x5E, 0xD1, 0xA1, 0x44, 0x25, 0xDA, 0x43, 
        0x19, 0xB7, 0xB2, 0x6B, 0x0E, 0x8F, 0xEF, 0x17, 
        0xC3, 0x75, 0x42, 0xAE, 0x5C, 0x6D, 0x58, 0x49, 
        0xF8, 0x72, 0x09, 0x56, 0x7F, 0x39, 0x25, 0xA4, 
        0x7B, 0x01, 0x6D, 0x56, 0x48, 0x59, 0x71, 0x7B, 
        0xC5, 0x7F, 0xCB, 0x45, 0x22, 0xD0, 0xAA, 0x49, 
        0xCE, 0x81, 0x6E, 0x5B, 0xE7, 0xB3, 0x08, 0x81, 
        0x93, 0x23, 0x6E, 0xC9, 0xEF, 0xFF, 0x14, 0x08, 
        0x58, 0x04, 0x5B, 0x73, 0xC5, 0xD7, 0x9B, 0xAF, 
        0x38, 0xF7, 0xC6, 0x7F, 0x04, 0xC5, 0xDC, 0xF0, 
        0xE3, 0x80, 0x6A, 0xD9, 0x82, 0xD1, 0x25, 0x90, 
        0x58, 0xC3, 0x47, 0x3E, 0x84, 0x71, 0x79, 0xA8, 
        0x78, 0xF2, 0xC6, 0xB3, 0xBD, 0x96, 0x8F, 0xB9,
        0x9E, 0xA4, 0x6E, 0x91, 0x85, 0x89, 0x2F, 0x36,
        0x76, 0xE7, 0x89, 0x65, 0xC2, 0xAE, 0xD4, 0x87,
        0x7B, 0xA3, 0x91, 0x7D, 0xF0, 0x7C, 0x5E, 0x92, 
        0x74, 0x74, 0xF1, 0x9E, 0x76, 0x4B, 0xA6, 0x1D, 
        0xC3, 0x8D, 0x63, 0xBF, 0x29, 0x02, 0x81, 0x81, 
        0x00, 0xD5, 0xC6, 0x9C, 0x8C, 0x3C, 0xDC, 0x24, 
        0x64, 0x74, 0x4A, 0x79, 0x37, 0x13, 0xDA, 0xFB, 
        0x9F, 0x1D, 0xBC, 0x79, 0x9F, 0xF9, 0x64, 0x23, 
        0xFE, 0xCD, 0x3C, 0xBA, 0x79, 0x42, 0x86, 0xBC, 
        0xE9, 0x20, 0xF4, 0xB5, 0xC1, 0x83, 0xF9, 0x9E, 
        0xE9, 0x02, 0x8D, 0xB6, 0x21, 0x2C, 0x62, 0x77, 
        0xC4, 0xC8, 0x29, 0x7F, 0xCF, 0xBC, 0xE7, 0xF7,
        0xC2, 0x4C, 0xA4, 0xC5, 0x1F, 0xC7, 0x18, 0x2F, 
        0xB8, 0xF4, 0x01, 0x9F, 0xB1, 0xD5, 0x65, 0x96, 
        0x74, 0xC5, 0xCB, 0xE6, 0xD5, 0xFA, 0x99, 0x20, 
        0x51, 0x34, 0x17, 0x60, 0xCD, 0x00, 0x73, 0x57, 
        0x29, 0xA0, 0x70, 0xA9, 0xE5, 0x4D, 0x34, 0x2B, 
        0xEB, 0xA8, 0xEF, 0x47, 0xEE, 0x82, 0xD3, 0xA0, 
        0x1B, 0x04, 0xCE, 0xC4, 0xA0, 0x0D, 0x4D, 0xDB,
        0x41, 0xE3, 0x51, 0x16, 0xFC, 0x22, 0x1E, 0x85, 
        0x4B, 0x43, 0xA6, 0x96, 0xC0, 0xE6, 0x41, 0x9B, 
        0x1B, 0x02, 0x81, 0x81, 0x00, 0xCD, 0x5E, 0xA7, 
        0x70, 0x27, 0x89, 0x06, 0x4B, 0x67, 0x35, 0x40, 
        0xCB, 0xFF, 0x09, 0x35, 0x6A, 0xD8, 0x0B, 0xC3, 
        0xD5, 0x92, 0x81, 0x2E, 0xBA, 0x47, 0x61, 0x0B,
        0x9F, 0xAC, 0x6A, 0xEC, 0xEF, 0xE2, 0x2A, 0xCA, 
        0xE4, 0x38, 0x45, 0x9C, 0xDA, 0x74, 0xE5, 0x96, 
        0x53, 0xD8, 0x8C, 0x04, 0x18, 0x9D, 0x34, 0x39, 
        0x9B, 0xF5, 0xB1, 0x4B, 0x92, 0x0E, 0x34, 0xEF, 
        0x38, 0xA7, 0xD0, 0x9F, 0xE6, 0x95, 0x93, 0x39, 
        0x6E, 0x8F, 0xE7, 0x35, 0xE6, 0xF0, 0xA6, 0xAE, 
        0x49, 0x90, 0x40, 0x10, 0x41, 0xD8, 0xA4, 0x06, 
        0xB6, 0xFD, 0x86, 0xA1, 0x16, 0x1E, 0x45, 0xF9,
        0x5A, 0x3E, 0xAA, 0x5C, 0x10, 0x12, 0xE6, 0x66,
        0x2E, 0x44, 0xF1, 0x5F, 0x33, 0x5A, 0xC9, 0x71, 
        0xE1, 0x76, 0x6B, 0x2B, 0xB9, 0xC9, 0x85, 0x10, 
        0x99, 0x74, 0x14, 0x1B, 0x44, 0xD3, 0x7E, 0x1E, 
        0x31, 0x98, 0x20, 0xA5, 0x5F, 0x02, 0x81, 0x81, 
        0x00, 0xB2, 0x87, 0x12, 0x37, 0xBF, 0x9F, 0xAD, 
        0x38, 0xC3, 0x31, 0x6A, 0xB7, 0x87, 0x7A, 0x6A, 
        0x86, 0x80, 0x63, 0xE5, 0x42, 0xA7, 0x18, 0x6D, 
        0x43, 0x1E, 0x8D, 0x27, 0xC1, 0x9A, 0xC0, 0x41, 
        0x45, 0x84, 0x03, 0x39, 0x42, 0xE9, 0xFF, 0x6E, 
        0x29, 0x73, 0xBB, 0x7B, 0x2D, 0x8B, 0x0E, 0x94, 
        0xAD, 0x1E, 0xE8, 0x21, 0x58, 0x10, 0x8F, 0xBC,
        0x86, 0x64, 0x51, 0x7A, 0x5A, 0x46, 0x7F, 0xB9, 
        0x63, 0x01, 0x4B, 0xD5, 0xDC, 0xC2, 0xB4, 0xFB, 
        0x08, 0x7C, 0x23, 0x03, 0x9D, 0x11, 0x92, 0x0D, 
        0xBE, 0x22, 0xFD, 0x9F, 0x16, 0xB4, 0xD8, 0x9E, 
        0x23, 0x22, 0x5C, 0xD4, 0x55, 0xAD, 0xBA, 0xF3, 
        0x2E, 0xF4, 0x3F, 0x18, 0x58, 0x64, 0xA3, 0x6D,
        0x63, 0x03, 0x09, 0xD6, 0x85, 0x3F, 0x77, 0x14,
        0xB3, 0x9A, 0xAE, 0x1E, 0xBE, 0xE3, 0x93, 0x8F, 
        0x87, 0xC2, 0x70, 0x7E, 0x17, 0x8C, 0x73, 0x9F, 
        0x9F, 0x02, 0x81, 0x81, 0x00, 0x96, 0x90, 0xBE,
        0xD1, 0x4B, 0x2A, 0xFA, 0xA2, 0x6D, 0x98, 0x6D, 
        0x59, 0x22, 0x31, 0xEE, 0x27, 0xD7, 0x1D, 0x49, 
        0x06, 0x5B, 0xD2, 0xBA, 0x1F, 0x78, 0x15, 0x7E, 
        0x20, 0x22, 0x98, 0x81, 0xFD, 0x9D, 0x23, 0x22, 
        0x7D, 0x0F, 0x84, 0x79, 0xEA, 0xEF, 0xA9, 0x22, 
        0xFD, 0x75, 0xD5, 0xB1, 0x6B, 0x1A, 0x56, 0x1F,
        0xA6, 0x68, 0x0B, 0x04, 0x0C, 0xA0, 0xBD, 0xCE, 
        0x65, 0x0B, 0x23, 0xB9, 0x17, 0xA4, 0xB1, 0xBB, 
        0x79, 0x83, 0xA7, 0x4F, 0xAD, 0x70, 0xE1, 0xC3, 
        0x05, 0xCB, 0xEC, 0x2B, 0xFF, 0x1A, 0x85, 0xA7,
        0x26, 0xA1, 0xD9, 0x02, 0x60, 0xE4, 0xF1, 0x08, 
        0x4F, 0x51, 0x82, 0x34, 0xDC, 0xD3, 0xFE, 0x77, 
        0x0B, 0x95, 0x20, 0x21, 0x5B, 0xD5, 0x43, 0xBB, 
        0x6A, 0x41, 0x17, 0x71, 0x87, 0x54, 0x67, 0x6A, 
        0x34, 0x17, 0x16, 0x66, 0xA7, 0x9F, 0x26, 0xE7, 
        0x9C, 0x14, 0x9C, 0x5A, 0xA1, 0x02, 0x81, 0x81, 
        0x00, 0xA0, 0xC9, 0x85, 0xA0, 0xA0, 0xA7, 0x91, 
        0xA6, 0x59, 0xF9, 0x97, 0x31, 0x13, 0x4C, 0x44, 
        0xF3, 0x7B, 0x2E, 0x52, 0x0A, 0x2C, 0xEA, 0x35, 
        0x80, 0x0A, 0xD2, 0x72, 0x41, 0xED, 0x36, 0x0D, 
        0xFD, 0xE6, 0xE8, 0xCA, 0x61, 0x4F, 0x12, 0x04, 
        0x7F, 0xD0, 0x8B, 0x76, 0xAC, 0x4D, 0x13, 0xC0, 
        0x56, 0xA0, 0x69, 0x9E, 0x2F, 0x98, 0xA1, 0xCA, 
        0xC9, 0x10, 0x11, 0x29, 0x4D, 0x71, 0x20, 0x8F, 
        0x4A, 0xBA, 0xB3, 0x3B, 0xA8, 0x7A, 0xA0, 0x51, 
        0x7F, 0x41, 0x5B, 0xAC, 0xA8, 0x8D, 0x6B, 0xAC, 
        0x00, 0x60, 0x88, 0xFA, 0x60, 0x1D, 0x34, 0x94, 
        0x17, 0xE1, 0xF0, 0xC9, 0xB2, 0x3A, 0xFF, 0xA4, 
        0xD4, 0x96, 0x61, 0x8D, 0xBC, 0x02, 0x49, 0x86, 
        0xED, 0x69, 0x0B, 0xBB, 0x7B, 0x02, 0x57, 0x68, 
        0xFF, 0x9D, 0xF8, 0xAC, 0x15, 0x41, 0x6F, 0x48, 
        0x9F, 0x81, 0x29, 0xC3, 0x23, 0x41, 0xA8, 0xB4, 
        0x4F
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_PKCS1;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    kb.cryptographic_length = 2048;
    
    struct private_key pk = {0};
    pk.key_block = &kb;
    
    int result = encode_private_key(&ctx, &pk);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_private_key(void)
{
    uint8 encoding[1280] = {
        0x42, 0x00, 0x64, 0x01, 0x00, 0x00, 0x04, 0xF8, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x04, 0xF0, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x04, 0xB8, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x04, 0xA9,
        0x30, 0x82, 0x04, 0xA5, 0x02, 0x01, 0x00, 0x02, 
        0x82, 0x01, 0x01, 0x00, 0xAB, 0x7F, 0x16, 0x1C, 
        0x00, 0x42, 0x49, 0x6C, 0xCD, 0x6C, 0x6D, 0x4D, 
        0xAD, 0xB9, 0x19, 0x97, 0x34, 0x35, 0x35, 0x77, 
        0x76, 0x00, 0x3A, 0xCF, 0x54, 0xB7, 0xAF, 0x1E, 
        0x44, 0x0A, 0xFB, 0x80, 0xB6, 0x4A, 0x87, 0x55, 
        0xF8, 0x00, 0x2C, 0xFE, 0xBA, 0x6B, 0x18, 0x45, 
        0x40, 0xA2, 0xD6, 0x60, 0x86, 0xD7, 0x46, 0x48, 
        0x34, 0x6D, 0x75, 0xB8, 0xD7, 0x18, 0x12, 0xB2, 
        0x05, 0x38, 0x7C, 0x0F, 0x65, 0x83, 0xBC, 0x4D, 
        0x7D, 0xC7, 0xEC, 0x11, 0x4F, 0x3B, 0x17, 0x6B, 
        0x79, 0x57, 0xC4, 0x22, 0xE7, 0xD0, 0x3F, 0xC6,
        0x26, 0x7F, 0xA2, 0xA6, 0xF8, 0x9B, 0x9B, 0xEE, 
        0x9E, 0x60, 0xA1, 0xD7, 0xC2, 0xD8, 0x33, 0xE5, 
        0xA5, 0xF4, 0xBB, 0x0B, 0x14, 0x34, 0xF4, 0xE7, 
        0x95, 0xA4, 0x11, 0x00, 0xF8, 0xAA, 0x21, 0x49, 
        0x00, 0xDF, 0x8B, 0x65, 0x08, 0x9F, 0x98, 0x13, 
        0x5B, 0x1C, 0x67, 0xB7, 0x01, 0x67, 0x5A, 0xBD, 
        0xBC, 0x7D, 0x57, 0x21, 0xAA, 0xC9, 0xD1, 0x4A, 
        0x7F, 0x08, 0x1F, 0xCE, 0xC8, 0x0B, 0x64, 0xE8, 
        0xA0, 0xEC, 0xC8, 0x29, 0x53, 0x53, 0xC7, 0x95, 
        0x32, 0x8A, 0xBF, 0x70, 0xE1, 0xB4, 0x2E, 0x7B, 
        0xB8, 0xB7, 0xF4, 0xE8, 0xAC, 0x8C, 0x81, 0x0C, 
        0xDB, 0x66, 0xE3, 0xD2, 0x11, 0x26, 0xEB, 0xA8, 
        0xDA, 0x7D, 0x0C, 0xA3, 0x41, 0x42, 0xCB, 0x76, 
        0xF9, 0x1F, 0x01, 0x3D, 0xA8, 0x09, 0xE9, 0xC1, 
        0xB7, 0xAE, 0x64, 0xC5, 0x41, 0x30, 0xFB, 0xC2, 
        0x1D, 0x80, 0xE9, 0xC2, 0xCB, 0x06, 0xC5, 0xC8, 
        0xD7, 0xCC, 0xE8, 0x94, 0x6A, 0x9A, 0xC9, 0x9B,
        0x1C, 0x28, 0x15, 0xC3, 0x61, 0x2A, 0x29, 0xA8, 
        0x2D, 0x73, 0xA1, 0xF9, 0x93, 0x74, 0xFE, 0x30, 
        0xE5, 0x49, 0x51, 0x66, 0x2A, 0x6E, 0xDA, 0x29, 
        0xC6, 0xFC, 0x41, 0x13, 0x35, 0xD5, 0xDC, 0x74, 
        0x26, 0xB0, 0xF6, 0x05, 0x02, 0x03, 0x01, 0x00, 
        0x01, 0x02, 0x82, 0x01, 0x00, 0x3B, 0x12, 0x45, 
        0x5D, 0x53, 0xC1, 0x81, 0x65, 0x16, 0xC5, 0x18, 
        0x49, 0x3F, 0x63, 0x98, 0xAA, 0xFA, 0x72, 0xB1, 
        0x7D, 0xFA, 0x89, 0x4D, 0xB8, 0x88, 0xA7, 0xD4, 
        0x8C, 0x0A, 0x47, 0xF6, 0x25, 0x79, 0xA4, 0xE6, 
        0x44, 0xF8, 0x6D, 0xA7, 0x11, 0xFE, 0xC8, 0x50, 
        0xCD, 0xD9, 0xDB, 0xBD, 0x17, 0xF6, 0x9A, 0x44, 
        0x3D, 0x2E, 0xC1, 0xDD, 0x60, 0xD3, 0xC6, 0x18, 
        0xFA, 0x74, 0xCD, 0xE5, 0xFD, 0xAF, 0xAB, 0xD6, 
        0xBA, 0xA2, 0x6E, 0xB0, 0xA3, 0xAD, 0xB4, 0xDE, 
        0xF6, 0x48, 0x0F, 0xB1, 0x21, 0x8C, 0xD3, 0xB0,
        0x83, 0xE2, 0x52, 0xE8, 0x85, 0xB6, 0xF0, 0x72, 
        0x9F, 0x98, 0xB2, 0x14, 0x4D, 0x2B, 0x72, 0x29, 
        0x3E, 0x1B, 0x11, 0xD7, 0x33, 0x93, 0xBC, 0x41, 
        0xF7, 0x5B, 0x15, 0xEE, 0x3D, 0x75, 0x69, 0xB4, 
        0x99, 0x5E, 0xD1, 0xA1, 0x44, 0x25, 0xDA, 0x43, 
        0x19, 0xB7, 0xB2, 0x6B, 0x0E, 0x8F, 0xEF, 0x17, 
        0xC3, 0x75, 0x42, 0xAE, 0x5C, 0x6D, 0x58, 0x49, 
        0xF8, 0x72, 0x09, 0x56, 0x7F, 0x39, 0x25, 0xA4, 
        0x7B, 0x01, 0x6D, 0x56, 0x48, 0x59, 0x71, 0x7B, 
        0xC5, 0x7F, 0xCB, 0x45, 0x22, 0xD0, 0xAA, 0x49, 
        0xCE, 0x81, 0x6E, 0x5B, 0xE7, 0xB3, 0x08, 0x81, 
        0x93, 0x23, 0x6E, 0xC9, 0xEF, 0xFF, 0x14, 0x08, 
        0x58, 0x04, 0x5B, 0x73, 0xC5, 0xD7, 0x9B, 0xAF, 
        0x38, 0xF7, 0xC6, 0x7F, 0x04, 0xC5, 0xDC, 0xF0, 
        0xE3, 0x80, 0x6A, 0xD9, 0x82, 0xD1, 0x25, 0x90, 
        0x58, 0xC3, 0x47, 0x3E, 0x84, 0x71, 0x79, 0xA8, 
        0x78, 0xF2, 0xC6, 0xB3, 0xBD, 0x96, 0x8F, 0xB9,
        0x9E, 0xA4, 0x6E, 0x91, 0x85, 0x89, 0x2F, 0x36,
        0x76, 0xE7, 0x89, 0x65, 0xC2, 0xAE, 0xD4, 0x87,
        0x7B, 0xA3, 0x91, 0x7D, 0xF0, 0x7C, 0x5E, 0x92, 
        0x74, 0x74, 0xF1, 0x9E, 0x76, 0x4B, 0xA6, 0x1D, 
        0xC3, 0x8D, 0x63, 0xBF, 0x29, 0x02, 0x81, 0x81, 
        0x00, 0xD5, 0xC6, 0x9C, 0x8C, 0x3C, 0xDC, 0x24, 
        0x64, 0x74, 0x4A, 0x79, 0x37, 0x13, 0xDA, 0xFB, 
        0x9F, 0x1D, 0xBC, 0x79, 0x9F, 0xF9, 0x64, 0x23, 
        0xFE, 0xCD, 0x3C, 0xBA, 0x79, 0x42, 0x86, 0xBC, 
        0xE9, 0x20, 0xF4, 0xB5, 0xC1, 0x83, 0xF9, 0x9E, 
        0xE9, 0x02, 0x8D, 0xB6, 0x21, 0x2C, 0x62, 0x77, 
        0xC4, 0xC8, 0x29, 0x7F, 0xCF, 0xBC, 0xE7, 0xF7,
        0xC2, 0x4C, 0xA4, 0xC5, 0x1F, 0xC7, 0x18, 0x2F, 
        0xB8, 0xF4, 0x01, 0x9F, 0xB1, 0xD5, 0x65, 0x96, 
        0x74, 0xC5, 0xCB, 0xE6, 0xD5, 0xFA, 0x99, 0x20, 
        0x51, 0x34, 0x17, 0x60, 0xCD, 0x00, 0x73, 0x57, 
        0x29, 0xA0, 0x70, 0xA9, 0xE5, 0x4D, 0x34, 0x2B, 
        0xEB, 0xA8, 0xEF, 0x47, 0xEE, 0x82, 0xD3, 0xA0, 
        0x1B, 0x04, 0xCE, 0xC4, 0xA0, 0x0D, 0x4D, 0xDB,
        0x41, 0xE3, 0x51, 0x16, 0xFC, 0x22, 0x1E, 0x85, 
        0x4B, 0x43, 0xA6, 0x96, 0xC0, 0xE6, 0x41, 0x9B, 
        0x1B, 0x02, 0x81, 0x81, 0x00, 0xCD, 0x5E, 0xA7, 
        0x70, 0x27, 0x89, 0x06, 0x4B, 0x67, 0x35, 0x40, 
        0xCB, 0xFF, 0x09, 0x35, 0x6A, 0xD8, 0x0B, 0xC3, 
        0xD5, 0x92, 0x81, 0x2E, 0xBA, 0x47, 0x61, 0x0B,
        0x9F, 0xAC, 0x6A, 0xEC, 0xEF, 0xE2, 0x2A, 0xCA, 
        0xE4, 0x38, 0x45, 0x9C, 0xDA, 0x74, 0xE5, 0x96, 
        0x53, 0xD8, 0x8C, 0x04, 0x18, 0x9D, 0x34, 0x39, 
        0x9B, 0xF5, 0xB1, 0x4B, 0x92, 0x0E, 0x34, 0xEF, 
        0x38, 0xA7, 0xD0, 0x9F, 0xE6, 0x95, 0x93, 0x39, 
        0x6E, 0x8F, 0xE7, 0x35, 0xE6, 0xF0, 0xA6, 0xAE, 
        0x49, 0x90, 0x40, 0x10, 0x41, 0xD8, 0xA4, 0x06, 
        0xB6, 0xFD, 0x86, 0xA1, 0x16, 0x1E, 0x45, 0xF9,
        0x5A, 0x3E, 0xAA, 0x5C, 0x10, 0x12, 0xE6, 0x66,
        0x2E, 0x44, 0xF1, 0x5F, 0x33, 0x5A, 0xC9, 0x71, 
        0xE1, 0x76, 0x6B, 0x2B, 0xB9, 0xC9, 0x85, 0x10, 
        0x99, 0x74, 0x14, 0x1B, 0x44, 0xD3, 0x7E, 0x1E, 
        0x31, 0x98, 0x20, 0xA5, 0x5F, 0x02, 0x81, 0x81, 
        0x00, 0xB2, 0x87, 0x12, 0x37, 0xBF, 0x9F, 0xAD, 
        0x38, 0xC3, 0x31, 0x6A, 0xB7, 0x87, 0x7A, 0x6A, 
        0x86, 0x80, 0x63, 0xE5, 0x42, 0xA7, 0x18, 0x6D, 
        0x43, 0x1E, 0x8D, 0x27, 0xC1, 0x9A, 0xC0, 0x41, 
        0x45, 0x84, 0x03, 0x39, 0x42, 0xE9, 0xFF, 0x6E, 
        0x29, 0x73, 0xBB, 0x7B, 0x2D, 0x8B, 0x0E, 0x94, 
        0xAD, 0x1E, 0xE8, 0x21, 0x58, 0x10, 0x8F, 0xBC,
        0x86, 0x64, 0x51, 0x7A, 0x5A, 0x46, 0x7F, 0xB9, 
        0x63, 0x01, 0x4B, 0xD5, 0xDC, 0xC2, 0xB4, 0xFB, 
        0x08, 0x7C, 0x23, 0x03, 0x9D, 0x11, 0x92, 0x0D, 
        0xBE, 0x22, 0xFD, 0x9F, 0x16, 0xB4, 0xD8, 0x9E, 
        0x23, 0x22, 0x5C, 0xD4, 0x55, 0xAD, 0xBA, 0xF3, 
        0x2E, 0xF4, 0x3F, 0x18, 0x58, 0x64, 0xA3, 0x6D,
        0x63, 0x03, 0x09, 0xD6, 0x85, 0x3F, 0x77, 0x14,
        0xB3, 0x9A, 0xAE, 0x1E, 0xBE, 0xE3, 0x93, 0x8F, 
        0x87, 0xC2, 0x70, 0x7E, 0x17, 0x8C, 0x73, 0x9F, 
        0x9F, 0x02, 0x81, 0x81, 0x00, 0x96, 0x90, 0xBE,
        0xD1, 0x4B, 0x2A, 0xFA, 0xA2, 0x6D, 0x98, 0x6D, 
        0x59, 0x22, 0x31, 0xEE, 0x27, 0xD7, 0x1D, 0x49, 
        0x06, 0x5B, 0xD2, 0xBA, 0x1F, 0x78, 0x15, 0x7E, 
        0x20, 0x22, 0x98, 0x81, 0xFD, 0x9D, 0x23, 0x22, 
        0x7D, 0x0F, 0x84, 0x79, 0xEA, 0xEF, 0xA9, 0x22, 
        0xFD, 0x75, 0xD5, 0xB1, 0x6B, 0x1A, 0x56, 0x1F,
        0xA6, 0x68, 0x0B, 0x04, 0x0C, 0xA0, 0xBD, 0xCE, 
        0x65, 0x0B, 0x23, 0xB9, 0x17, 0xA4, 0xB1, 0xBB, 
        0x79, 0x83, 0xA7, 0x4F, 0xAD, 0x70, 0xE1, 0xC3, 
        0x05, 0xCB, 0xEC, 0x2B, 0xFF, 0x1A, 0x85, 0xA7,
        0x26, 0xA1, 0xD9, 0x02, 0x60, 0xE4, 0xF1, 0x08, 
        0x4F, 0x51, 0x82, 0x34, 0xDC, 0xD3, 0xFE, 0x77, 
        0x0B, 0x95, 0x20, 0x21, 0x5B, 0xD5, 0x43, 0xBB, 
        0x6A, 0x41, 0x17, 0x71, 0x87, 0x54, 0x67, 0x6A, 
        0x34, 0x17, 0x16, 0x66, 0xA7, 0x9F, 0x26, 0xE7, 
        0x9C, 0x14, 0x9C, 0x5A, 0xA1, 0x02, 0x81, 0x81, 
        0x00, 0xA0, 0xC9, 0x85, 0xA0, 0xA0, 0xA7, 0x91, 
        0xA6, 0x59, 0xF9, 0x97, 0x31, 0x13, 0x4C, 0x44, 
        0xF3, 0x7B, 0x2E, 0x52, 0x0A, 0x2C, 0xEA, 0x35, 
        0x80, 0x0A, 0xD2, 0x72, 0x41, 0xED, 0x36, 0x0D, 
        0xFD, 0xE6, 0xE8, 0xCA, 0x61, 0x4F, 0x12, 0x04, 
        0x7F, 0xD0, 0x8B, 0x76, 0xAC, 0x4D, 0x13, 0xC0, 
        0x56, 0xA0, 0x69, 0x9E, 0x2F, 0x98, 0xA1, 0xCA, 
        0xC9, 0x10, 0x11, 0x29, 0x4D, 0x71, 0x20, 0x8F, 
        0x4A, 0xBA, 0xB3, 0x3B, 0xA8, 0x7A, 0xA0, 0x51, 
        0x7F, 0x41, 0x5B, 0xAC, 0xA8, 0x8D, 0x6B, 0xAC, 
        0x00, 0x60, 0x88, 0xFA, 0x60, 0x1D, 0x34, 0x94, 
        0x17, 0xE1, 0xF0, 0xC9, 0xB2, 0x3A, 0xFF, 0xA4, 
        0xD4, 0x96, 0x61, 0x8D, 0xBC, 0x02, 0x49, 0x86, 
        0xED, 0x69, 0x0B, 0xBB, 0x7B, 0x02, 0x57, 0x68, 
        0xFF, 0x9D, 0xF8, 0xAC, 0x15, 0x41, 0x6F, 0x48, 
        0x9F, 0x81, 0x29, 0xC3, 0x23, 0x41, 0xA8, 0xB4, 
        0x4F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    uint8 value[1193] = {
        0x30, 0x82, 0x04, 0xA5, 0x02, 0x01, 0x00, 0x02, 
        0x82, 0x01, 0x01, 0x00, 0xAB, 0x7F, 0x16, 0x1C, 
        0x00, 0x42, 0x49, 0x6C, 0xCD, 0x6C, 0x6D, 0x4D, 
        0xAD, 0xB9, 0x19, 0x97, 0x34, 0x35, 0x35, 0x77, 
        0x76, 0x00, 0x3A, 0xCF, 0x54, 0xB7, 0xAF, 0x1E, 
        0x44, 0x0A, 0xFB, 0x80, 0xB6, 0x4A, 0x87, 0x55, 
        0xF8, 0x00, 0x2C, 0xFE, 0xBA, 0x6B, 0x18, 0x45, 
        0x40, 0xA2, 0xD6, 0x60, 0x86, 0xD7, 0x46, 0x48, 
        0x34, 0x6D, 0x75, 0xB8, 0xD7, 0x18, 0x12, 0xB2, 
        0x05, 0x38, 0x7C, 0x0F, 0x65, 0x83, 0xBC, 0x4D, 
        0x7D, 0xC7, 0xEC, 0x11, 0x4F, 0x3B, 0x17, 0x6B, 
        0x79, 0x57, 0xC4, 0x22, 0xE7, 0xD0, 0x3F, 0xC6,
        0x26, 0x7F, 0xA2, 0xA6, 0xF8, 0x9B, 0x9B, 0xEE, 
        0x9E, 0x60, 0xA1, 0xD7, 0xC2, 0xD8, 0x33, 0xE5, 
        0xA5, 0xF4, 0xBB, 0x0B, 0x14, 0x34, 0xF4, 0xE7, 
        0x95, 0xA4, 0x11, 0x00, 0xF8, 0xAA, 0x21, 0x49, 
        0x00, 0xDF, 0x8B, 0x65, 0x08, 0x9F, 0x98, 0x13, 
        0x5B, 0x1C, 0x67, 0xB7, 0x01, 0x67, 0x5A, 0xBD, 
        0xBC, 0x7D, 0x57, 0x21, 0xAA, 0xC9, 0xD1, 0x4A, 
        0x7F, 0x08, 0x1F, 0xCE, 0xC8, 0x0B, 0x64, 0xE8, 
        0xA0, 0xEC, 0xC8, 0x29, 0x53, 0x53, 0xC7, 0x95, 
        0x32, 0x8A, 0xBF, 0x70, 0xE1, 0xB4, 0x2E, 0x7B, 
        0xB8, 0xB7, 0xF4, 0xE8, 0xAC, 0x8C, 0x81, 0x0C, 
        0xDB, 0x66, 0xE3, 0xD2, 0x11, 0x26, 0xEB, 0xA8, 
        0xDA, 0x7D, 0x0C, 0xA3, 0x41, 0x42, 0xCB, 0x76, 
        0xF9, 0x1F, 0x01, 0x3D, 0xA8, 0x09, 0xE9, 0xC1, 
        0xB7, 0xAE, 0x64, 0xC5, 0x41, 0x30, 0xFB, 0xC2, 
        0x1D, 0x80, 0xE9, 0xC2, 0xCB, 0x06, 0xC5, 0xC8, 
        0xD7, 0xCC, 0xE8, 0x94, 0x6A, 0x9A, 0xC9, 0x9B,
        0x1C, 0x28, 0x15, 0xC3, 0x61, 0x2A, 0x29, 0xA8, 
        0x2D, 0x73, 0xA1, 0xF9, 0x93, 0x74, 0xFE, 0x30, 
        0xE5, 0x49, 0x51, 0x66, 0x2A, 0x6E, 0xDA, 0x29, 
        0xC6, 0xFC, 0x41, 0x13, 0x35, 0xD5, 0xDC, 0x74, 
        0x26, 0xB0, 0xF6, 0x05, 0x02, 0x03, 0x01, 0x00, 
        0x01, 0x02, 0x82, 0x01, 0x00, 0x3B, 0x12, 0x45, 
        0x5D, 0x53, 0xC1, 0x81, 0x65, 0x16, 0xC5, 0x18, 
        0x49, 0x3F, 0x63, 0x98, 0xAA, 0xFA, 0x72, 0xB1, 
        0x7D, 0xFA, 0x89, 0x4D, 0xB8, 0x88, 0xA7, 0xD4, 
        0x8C, 0x0A, 0x47, 0xF6, 0x25, 0x79, 0xA4, 0xE6, 
        0x44, 0xF8, 0x6D, 0xA7, 0x11, 0xFE, 0xC8, 0x50, 
        0xCD, 0xD9, 0xDB, 0xBD, 0x17, 0xF6, 0x9A, 0x44, 
        0x3D, 0x2E, 0xC1, 0xDD, 0x60, 0xD3, 0xC6, 0x18, 
        0xFA, 0x74, 0xCD, 0xE5, 0xFD, 0xAF, 0xAB, 0xD6, 
        0xBA, 0xA2, 0x6E, 0xB0, 0xA3, 0xAD, 0xB4, 0xDE, 
        0xF6, 0x48, 0x0F, 0xB1, 0x21, 0x8C, 0xD3, 0xB0,
        0x83, 0xE2, 0x52, 0xE8, 0x85, 0xB6, 0xF0, 0x72, 
        0x9F, 0x98, 0xB2, 0x14, 0x4D, 0x2B, 0x72, 0x29, 
        0x3E, 0x1B, 0x11, 0xD7, 0x33, 0x93, 0xBC, 0x41, 
        0xF7, 0x5B, 0x15, 0xEE, 0x3D, 0x75, 0x69, 0xB4, 
        0x99, 0x5E, 0xD1, 0xA1, 0x44, 0x25, 0xDA, 0x43, 
        0x19, 0xB7, 0xB2, 0x6B, 0x0E, 0x8F, 0xEF, 0x17, 
        0xC3, 0x75, 0x42, 0xAE, 0x5C, 0x6D, 0x58, 0x49, 
        0xF8, 0x72, 0x09, 0x56, 0x7F, 0x39, 0x25, 0xA4, 
        0x7B, 0x01, 0x6D, 0x56, 0x48, 0x59, 0x71, 0x7B, 
        0xC5, 0x7F, 0xCB, 0x45, 0x22, 0xD0, 0xAA, 0x49, 
        0xCE, 0x81, 0x6E, 0x5B, 0xE7, 0xB3, 0x08, 0x81, 
        0x93, 0x23, 0x6E, 0xC9, 0xEF, 0xFF, 0x14, 0x08, 
        0x58, 0x04, 0x5B, 0x73, 0xC5, 0xD7, 0x9B, 0xAF, 
        0x38, 0xF7, 0xC6, 0x7F, 0x04, 0xC5, 0xDC, 0xF0, 
        0xE3, 0x80, 0x6A, 0xD9, 0x82, 0xD1, 0x25, 0x90, 
        0x58, 0xC3, 0x47, 0x3E, 0x84, 0x71, 0x79, 0xA8, 
        0x78, 0xF2, 0xC6, 0xB3, 0xBD, 0x96, 0x8F, 0xB9,
        0x9E, 0xA4, 0x6E, 0x91, 0x85, 0x89, 0x2F, 0x36,
        0x76, 0xE7, 0x89, 0x65, 0xC2, 0xAE, 0xD4, 0x87,
        0x7B, 0xA3, 0x91, 0x7D, 0xF0, 0x7C, 0x5E, 0x92, 
        0x74, 0x74, 0xF1, 0x9E, 0x76, 0x4B, 0xA6, 0x1D, 
        0xC3, 0x8D, 0x63, 0xBF, 0x29, 0x02, 0x81, 0x81, 
        0x00, 0xD5, 0xC6, 0x9C, 0x8C, 0x3C, 0xDC, 0x24, 
        0x64, 0x74, 0x4A, 0x79, 0x37, 0x13, 0xDA, 0xFB, 
        0x9F, 0x1D, 0xBC, 0x79, 0x9F, 0xF9, 0x64, 0x23, 
        0xFE, 0xCD, 0x3C, 0xBA, 0x79, 0x42, 0x86, 0xBC, 
        0xE9, 0x20, 0xF4, 0xB5, 0xC1, 0x83, 0xF9, 0x9E, 
        0xE9, 0x02, 0x8D, 0xB6, 0x21, 0x2C, 0x62, 0x77, 
        0xC4, 0xC8, 0x29, 0x7F, 0xCF, 0xBC, 0xE7, 0xF7,
        0xC2, 0x4C, 0xA4, 0xC5, 0x1F, 0xC7, 0x18, 0x2F, 
        0xB8, 0xF4, 0x01, 0x9F, 0xB1, 0xD5, 0x65, 0x96, 
        0x74, 0xC5, 0xCB, 0xE6, 0xD5, 0xFA, 0x99, 0x20, 
        0x51, 0x34, 0x17, 0x60, 0xCD, 0x00, 0x73, 0x57, 
        0x29, 0xA0, 0x70, 0xA9, 0xE5, 0x4D, 0x34, 0x2B, 
        0xEB, 0xA8, 0xEF, 0x47, 0xEE, 0x82, 0xD3, 0xA0, 
        0x1B, 0x04, 0xCE, 0xC4, 0xA0, 0x0D, 0x4D, 0xDB,
        0x41, 0xE3, 0x51, 0x16, 0xFC, 0x22, 0x1E, 0x85, 
        0x4B, 0x43, 0xA6, 0x96, 0xC0, 0xE6, 0x41, 0x9B, 
        0x1B, 0x02, 0x81, 0x81, 0x00, 0xCD, 0x5E, 0xA7, 
        0x70, 0x27, 0x89, 0x06, 0x4B, 0x67, 0x35, 0x40, 
        0xCB, 0xFF, 0x09, 0x35, 0x6A, 0xD8, 0x0B, 0xC3, 
        0xD5, 0x92, 0x81, 0x2E, 0xBA, 0x47, 0x61, 0x0B,
        0x9F, 0xAC, 0x6A, 0xEC, 0xEF, 0xE2, 0x2A, 0xCA, 
        0xE4, 0x38, 0x45, 0x9C, 0xDA, 0x74, 0xE5, 0x96, 
        0x53, 0xD8, 0x8C, 0x04, 0x18, 0x9D, 0x34, 0x39, 
        0x9B, 0xF5, 0xB1, 0x4B, 0x92, 0x0E, 0x34, 0xEF, 
        0x38, 0xA7, 0xD0, 0x9F, 0xE6, 0x95, 0x93, 0x39, 
        0x6E, 0x8F, 0xE7, 0x35, 0xE6, 0xF0, 0xA6, 0xAE, 
        0x49, 0x90, 0x40, 0x10, 0x41, 0xD8, 0xA4, 0x06, 
        0xB6, 0xFD, 0x86, 0xA1, 0x16, 0x1E, 0x45, 0xF9,
        0x5A, 0x3E, 0xAA, 0x5C, 0x10, 0x12, 0xE6, 0x66,
        0x2E, 0x44, 0xF1, 0x5F, 0x33, 0x5A, 0xC9, 0x71, 
        0xE1, 0x76, 0x6B, 0x2B, 0xB9, 0xC9, 0x85, 0x10, 
        0x99, 0x74, 0x14, 0x1B, 0x44, 0xD3, 0x7E, 0x1E, 
        0x31, 0x98, 0x20, 0xA5, 0x5F, 0x02, 0x81, 0x81, 
        0x00, 0xB2, 0x87, 0x12, 0x37, 0xBF, 0x9F, 0xAD, 
        0x38, 0xC3, 0x31, 0x6A, 0xB7, 0x87, 0x7A, 0x6A, 
        0x86, 0x80, 0x63, 0xE5, 0x42, 0xA7, 0x18, 0x6D, 
        0x43, 0x1E, 0x8D, 0x27, 0xC1, 0x9A, 0xC0, 0x41, 
        0x45, 0x84, 0x03, 0x39, 0x42, 0xE9, 0xFF, 0x6E, 
        0x29, 0x73, 0xBB, 0x7B, 0x2D, 0x8B, 0x0E, 0x94, 
        0xAD, 0x1E, 0xE8, 0x21, 0x58, 0x10, 0x8F, 0xBC,
        0x86, 0x64, 0x51, 0x7A, 0x5A, 0x46, 0x7F, 0xB9, 
        0x63, 0x01, 0x4B, 0xD5, 0xDC, 0xC2, 0xB4, 0xFB, 
        0x08, 0x7C, 0x23, 0x03, 0x9D, 0x11, 0x92, 0x0D, 
        0xBE, 0x22, 0xFD, 0x9F, 0x16, 0xB4, 0xD8, 0x9E, 
        0x23, 0x22, 0x5C, 0xD4, 0x55, 0xAD, 0xBA, 0xF3, 
        0x2E, 0xF4, 0x3F, 0x18, 0x58, 0x64, 0xA3, 0x6D,
        0x63, 0x03, 0x09, 0xD6, 0x85, 0x3F, 0x77, 0x14,
        0xB3, 0x9A, 0xAE, 0x1E, 0xBE, 0xE3, 0x93, 0x8F, 
        0x87, 0xC2, 0x70, 0x7E, 0x17, 0x8C, 0x73, 0x9F, 
        0x9F, 0x02, 0x81, 0x81, 0x00, 0x96, 0x90, 0xBE,
        0xD1, 0x4B, 0x2A, 0xFA, 0xA2, 0x6D, 0x98, 0x6D, 
        0x59, 0x22, 0x31, 0xEE, 0x27, 0xD7, 0x1D, 0x49, 
        0x06, 0x5B, 0xD2, 0xBA, 0x1F, 0x78, 0x15, 0x7E, 
        0x20, 0x22, 0x98, 0x81, 0xFD, 0x9D, 0x23, 0x22, 
        0x7D, 0x0F, 0x84, 0x79, 0xEA, 0xEF, 0xA9, 0x22, 
        0xFD, 0x75, 0xD5, 0xB1, 0x6B, 0x1A, 0x56, 0x1F,
        0xA6, 0x68, 0x0B, 0x04, 0x0C, 0xA0, 0xBD, 0xCE, 
        0x65, 0x0B, 0x23, 0xB9, 0x17, 0xA4, 0xB1, 0xBB, 
        0x79, 0x83, 0xA7, 0x4F, 0xAD, 0x70, 0xE1, 0xC3, 
        0x05, 0xCB, 0xEC, 0x2B, 0xFF, 0x1A, 0x85, 0xA7,
        0x26, 0xA1, 0xD9, 0x02, 0x60, 0xE4, 0xF1, 0x08, 
        0x4F, 0x51, 0x82, 0x34, 0xDC, 0xD3, 0xFE, 0x77, 
        0x0B, 0x95, 0x20, 0x21, 0x5B, 0xD5, 0x43, 0xBB, 
        0x6A, 0x41, 0x17, 0x71, 0x87, 0x54, 0x67, 0x6A, 
        0x34, 0x17, 0x16, 0x66, 0xA7, 0x9F, 0x26, 0xE7, 
        0x9C, 0x14, 0x9C, 0x5A, 0xA1, 0x02, 0x81, 0x81, 
        0x00, 0xA0, 0xC9, 0x85, 0xA0, 0xA0, 0xA7, 0x91, 
        0xA6, 0x59, 0xF9, 0x97, 0x31, 0x13, 0x4C, 0x44, 
        0xF3, 0x7B, 0x2E, 0x52, 0x0A, 0x2C, 0xEA, 0x35, 
        0x80, 0x0A, 0xD2, 0x72, 0x41, 0xED, 0x36, 0x0D, 
        0xFD, 0xE6, 0xE8, 0xCA, 0x61, 0x4F, 0x12, 0x04, 
        0x7F, 0xD0, 0x8B, 0x76, 0xAC, 0x4D, 0x13, 0xC0, 
        0x56, 0xA0, 0x69, 0x9E, 0x2F, 0x98, 0xA1, 0xCA, 
        0xC9, 0x10, 0x11, 0x29, 0x4D, 0x71, 0x20, 0x8F, 
        0x4A, 0xBA, 0xB3, 0x3B, 0xA8, 0x7A, 0xA0, 0x51, 
        0x7F, 0x41, 0x5B, 0xAC, 0xA8, 0x8D, 0x6B, 0xAC, 
        0x00, 0x60, 0x88, 0xFA, 0x60, 0x1D, 0x34, 0x94, 
        0x17, 0xE1, 0xF0, 0xC9, 0xB2, 0x3A, 0xFF, 0xA4, 
        0xD4, 0x96, 0x61, 0x8D, 0xBC, 0x02, 0x49, 0x86, 
        0xED, 0x69, 0x0B, 0xBB, 0x7B, 0x02, 0x57, 0x68, 
        0xFF, 0x9D, 0xF8, 0xAC, 0x15, 0x41, 0x6F, 0x48, 
        0x9F, 0x81, 0x29, 0xC3, 0x23, 0x41, 0xA8, 0xB4, 
        0x4F
    };
    struct byte_string key = {0};
    key.value = value;
    key.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &key;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_PKCS1;
    kb.key_value = &kv;
    kb.key_value_type = KMIP_TYPE_STRUCTURE;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    kb.cryptographic_length = 2048;
    
    struct private_key expected = {0};
    expected.key_block = &kb;
    
    struct private_key observed = {0};
    
    int result = decode_private_key(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_private_key(&expected, &observed),
        result,
        __func__);
    free_private_key(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_wrapping_specification(void)
{
    uint8 expected[136] = {
        0x42, 0x00, 0x47, 0x01, 0x00, 0x00, 0x00, 0x80, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x34, 0x62, 0x32, 0x62, 0x34, 0x63, 0x33, 
        0x2D, 0x34, 0x63, 0x31, 0x39, 0x2D, 0x34, 0x65, 
        0x63, 0x66, 0x2D, 0x38, 0x32, 0x37, 0x61, 0x2D, 
        0x30, 0x31, 0x31, 0x63, 0x61, 0x36, 0x30, 0x35, 
        0x37, 0x64, 0x33, 0x65, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B
    };
    
    uint8 observed[136] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "f4b2b4c3-4c19-4ecf-827a-011ca6057d3e";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct text_string attribute_name = {0};
    attribute_name.value = "Cryptographic Usage Mask";
    attribute_name.size = 24;
    
    struct key_wrapping_specification kws = {0};
    kws.wrapping_method = KMIP_WRAP_ENCRYPT;
    kws.encryption_key_info = &eki;
    kws.attribute_names = &attribute_name;
    kws.attribute_name_count = 1;
    
    int result = encode_key_wrapping_specification(&ctx, &kws);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_wrapping_specification(void)
{
    uint8 encoding[136] = {
        0x42, 0x00, 0x47, 0x01, 0x00, 0x00, 0x00, 0x80, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x34, 0x62, 0x32, 0x62, 0x34, 0x63, 0x33, 
        0x2D, 0x34, 0x63, 0x31, 0x39, 0x2D, 0x34, 0x65, 
        0x63, 0x66, 0x2D, 0x38, 0x32, 0x37, 0x61, 0x2D, 
        0x30, 0x31, 0x31, 0x63, 0x61, 0x36, 0x30, 0x35, 
        0x37, 0x64, 0x33, 0x65, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "f4b2b4c3-4c19-4ecf-827a-011ca6057d3e";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    init_cryptographic_parameters(&cp);
    
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct text_string attribute_name = {0};
    attribute_name.value = "Cryptographic Usage Mask";
    attribute_name.size = 24;
    
    struct key_wrapping_specification expected = {0};
    expected.wrapping_method = KMIP_WRAP_ENCRYPT;
    expected.encryption_key_info = &eki;
    expected.attribute_names = &attribute_name;
    expected.attribute_name_count = 1;
    
    struct key_wrapping_specification observed = {0};
    
    int result = decode_key_wrapping_specification(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_key_wrapping_specification(&expected, &observed),
        result,
        __func__);
    free_key_wrapping_specification(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_create_request_payload(void)
{
    uint8 expected[200] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0xC0, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[200] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct attribute a[3] = {0};
    for(int i = 0; i < 3; i++)
    {
        init_attribute(&a[i]);
    }
    
    enum cryptographic_algorithm algorithm = KMIP_CRYPTOALG_AES;
    a[0].type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    a[0].value = &algorithm;
    
    int32 length = 128;
    a[1].type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    a[1].value = &length;
    
    int32 mask = KMIP_CRYPTOMASK_ENCRYPT | KMIP_CRYPTOMASK_DECRYPT;
    a[2].type = KMIP_ATTR_CRYPTOGRAPHIC_USAGE_MASK;
    a[2].value = &mask;
    
    struct template_attribute ta = {0};
    ta.attributes = a;
    ta.attribute_count = ARRAY_LENGTH(a);
    
    struct create_request_payload crp = {0};
    crp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    crp.template_attribute = &ta;
    
    int result = encode_create_request_payload(&ctx, &crp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_create_request_payload(void)
{
    uint8 encoding[200] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0xC0, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct attribute a[3] = {0};
    for(int i = 0; i < 3; i++)
    {
        init_attribute(&a[i]);
    }
    
    enum cryptographic_algorithm algorithm = KMIP_CRYPTOALG_AES;
    a[0].type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    a[0].value = &algorithm;
    
    int32 length = 128;
    a[1].type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    a[1].value = &length;
    
    int32 mask = KMIP_CRYPTOMASK_ENCRYPT | KMIP_CRYPTOMASK_DECRYPT;
    a[2].type = KMIP_ATTR_CRYPTOGRAPHIC_USAGE_MASK;
    a[2].value = &mask;
    
    struct template_attribute ta = {0};
    ta.attributes = a;
    ta.attribute_count = ARRAY_LENGTH(a);
    
    struct create_request_payload expected = {0};
    expected.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    expected.template_attribute = &ta;
    
    struct create_request_payload observed = {0};
    
    int result = decode_create_request_payload(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_create_request_payload(&expected, &observed),
        result,
        __func__);
    free_create_request_payload(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_create_response_payload(void)
{
    uint8 expected[72] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[72] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct create_response_payload crp = {0};
    crp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    crp.unique_identifier = &uuid;
    
    int result = encode_create_response_payload(&ctx, &crp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_create_response_payload(void)
{
    uint8 encoding[72] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct create_response_payload expected = {0};
    expected.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    expected.unique_identifier = &uuid;
    
    struct create_response_payload observed = {0};
    
    int result = decode_create_response_payload(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_create_response_payload(&expected, &observed),
        result,
        __func__);
    free_create_response_payload(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_create_response_payload_with_template_attribute(void)
{
    uint8 expected[136] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x80, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    };
    
    uint8 observed[136] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct attribute a = {0};
    init_attribute(&a);
    
    enum cryptographic_algorithm algorithm = KMIP_CRYPTOALG_AES;
    a.type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    a.value = &algorithm;
    
    struct template_attribute ta = {0};
    ta.attributes = &a;
    ta.attribute_count = 1;
    
    struct create_response_payload crp = {0};
    crp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    crp.unique_identifier = &uuid;
    crp.template_attribute = &ta;
    
    int result = encode_create_response_payload(&ctx, &crp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_create_response_payload_with_template_attribute(void)
{
    uint8 encoding[136] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x80, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct attribute a = {0};
    init_attribute(&a);
    
    enum cryptographic_algorithm algorithm = KMIP_CRYPTOALG_AES;
    a.type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    a.value = &algorithm;
    
    struct template_attribute ta = {0};
    ta.attributes = &a;
    ta.attribute_count = 1;
    
    struct create_response_payload expected = {0};
    expected.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    expected.unique_identifier = &uuid;
    expected.template_attribute = &ta;
    
    struct create_response_payload observed = {0};
    
    int result = decode_create_response_payload(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_create_response_payload(&expected, &observed),
        result,
        __func__);
    free_create_response_payload(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_get_request_payload(void)
{
    uint8 expected[56] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[56] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    
    int result = encode_get_request_payload(&ctx, &grp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_get_request_payload(void)
{
    uint8 encoding[56] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct get_request_payload expected = {0};
    expected.unique_identifier = &uuid;
    
    struct get_request_payload observed = {0};
    
    int result = decode_get_request_payload(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_get_request_payload(&expected, &observed),
        result,
        __func__);
    free_get_request_payload(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_get_request_payload_with_format_compression(void)
{
    uint8 expected[88] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x50, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x37, 0x63, 0x66, 0x35, 0x32, 0x30, 0x39, 0x62, 
        0x2D, 0x36, 0x66, 0x66, 0x36, 0x2D, 0x34, 0x34, 
        0x32, 0x36, 0x2D, 0x38, 0x39, 0x39, 0x65, 0x2D, 
        0x32, 0x32, 0x62, 0x30, 0x36, 0x37, 0x38, 0x35, 
        0x39, 0x33, 0x37, 0x32, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x41, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[88] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "7cf5209b-6ff6-4426-899e-22b067859372";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    grp.key_format_type = KMIP_KEYFORMAT_PKCS1;
    grp.key_compression_type = KMIP_KEYCOMP_EC_PUB_UNCOMPRESSED;
    
    int result = encode_get_request_payload(&ctx, &grp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_get_request_payload_with_wrapping_spec(void)
{
    uint8 expected[160] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x98, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x62, 0x66, 0x66, 0x37, 0x33, 0x34, 0x37, 0x62, 
        0x2D, 0x33, 0x61, 0x33, 0x39, 0x2D, 0x34, 0x63, 
        0x63, 0x62, 0x2D, 0x38, 0x32, 0x33, 0x34, 0x2D, 
        0x62, 0x61, 0x32, 0x35, 0x36, 0x30, 0x63, 0x61, 
        0x31, 0x35, 0x39, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x47, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35, 
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[160] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string wrapping_uuid = {0};
    wrapping_uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    wrapping_uuid.size = 36;
    struct text_string uuid = {0};
    uuid.value = "bff7347b-3a39-4ccb-8234-ba2560ca1598";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &wrapping_uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_specification kws = {0};
    kws.wrapping_method = KMIP_WRAP_ENCRYPT;
    kws.encryption_key_info = &eki;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    grp.key_wrapping_spec = &kws;
    
    int result = encode_get_request_payload(&ctx, &grp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_get_response_payload(void)
{
    uint8 expected[176] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[176] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    struct byte_string v = {0};
    v.value = value;
    v.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &v;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_TRIPLE_DES;
    kb.cryptographic_length = 168;
    
    struct symmetric_key key = {0};
    key.key_block = &kb;
    
    struct get_response_payload grp = {0};
    grp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    grp.unique_identifier = &uuid;
    grp.object = &key;
    
    int result = encode_get_response_payload(&ctx, &grp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_get_response_payload(void)
{
    uint8 encoding[176] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    struct byte_string v = {0};
    v.value = value;
    v.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &v;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.key_value_type = KMIP_TYPE_STRUCTURE;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_TRIPLE_DES;
    kb.cryptographic_length = 168;
    
    struct symmetric_key key = {0};
    key.key_block = &kb;
    
    struct get_response_payload expected = {0};
    expected.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    expected.unique_identifier = &uuid;
    expected.object = &key;
    
    struct get_response_payload observed = {0};
    
    int result = decode_get_response_payload(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_get_response_payload(&expected, &observed),
        result,
        __func__);
    free_get_response_payload(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_destroy_request_payload(void)
{
    uint8 expected[56] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[56] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct destroy_request_payload drp = {0};
    drp.unique_identifier = &uuid;
    
    int result = encode_destroy_request_payload(&ctx, &drp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_destroy_request_payload(void)
{
    uint8 encoding[56] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct destroy_request_payload expected = {0};
    expected.unique_identifier = &uuid;
    
    struct destroy_request_payload observed = {0};
    
    int result = decode_destroy_request_payload(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_destroy_request_payload(&expected, &observed),
        result,
        __func__);
    free_destroy_request_payload(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_destroy_response_payload(void)
{
    uint8 expected[56] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[56] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct destroy_response_payload drp = {0};
    drp.unique_identifier = &uuid;
    
    int result = encode_destroy_response_payload(&ctx, &drp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_destroy_response_payload(void)
{
    uint8 encoding[56] = {
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x30,
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct destroy_response_payload expected = {0};
    expected.unique_identifier = &uuid;
    
    struct destroy_response_payload observed = {0};
    
    int result = decode_destroy_response_payload(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_destroy_response_payload(&expected, &observed),
        result,
        __func__);
    free_destroy_response_payload(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_username_password_credential(void)
{
    uint8 expected[48] = {
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x46, 0x72, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64, 
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[48] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string username = {0};
    username.value = "Fred";
    username.size = 4;
    struct text_string password = {0};
    password.value = "password1";
    password.size = 9;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    int result = encode_username_password_credential(&ctx, &upc);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_username_password_credential(void)
{
    uint8 encoding[48] = {
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x46, 0x72, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64, 
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string username = {0};
    username.value = "Fred";
    username.size = 4;
    struct text_string password = {0};
    password.value = "password1";
    password.size = 9;
    
    struct username_password_credential expected = {0};
    expected.username = &username;
    expected.password = &password;
    
    struct username_password_credential observed = {0};
    
    int result = decode_username_password_credential(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_username_password_credential(&expected, &observed),
        result,
        __func__);
    free_username_password_credential(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_credential_username_password_credential(void)
{
    uint8 expected[64] = {
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x42, 0x61, 0x72, 0x6E, 0x65, 0x79, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x07, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x32, 0x00
    };
    
    uint8 observed[64] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string username = {0};
    username.value = "Barney";
    username.size = 6;
    struct text_string password = {0};
    password.value = "secret2";
    password.size = 7;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential c = {0};
    c.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    c.credential_value = &upc;
    
    int result = encode_credential(&ctx, &c);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_credential_username_password_credential(void)
{
    uint8 encoding[64] = {
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x42, 0x61, 0x72, 0x6E, 0x65, 0x79, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x07, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x32, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string username = {0};
    username.value = "Barney";
    username.size = 6;
    struct text_string password = {0};
    password.value = "secret2";
    password.size = 7;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential expected = {0};
    expected.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    expected.credential_value = &upc;

    struct credential observed = {0};
    
    int result = decode_credential(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_credential(&expected, &observed),
        result,
        __func__);
    free_credential(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_authentication_username_password_credential(void)
{
    uint8 expected[80] = {
        0x42, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x46, 0x72, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64, 
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[80] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string username = {0};
    username.value = "Fred";
    username.size = 4;
    struct text_string password = {0};
    password.value = "password1";
    password.size = 9;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential c = {0};
    c.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    c.credential_value = &upc;
    
    struct authentication a = {0};
    a.credential = &c;
    
    int result = encode_authentication(&ctx, &a);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_authentication_username_password_credential(void)
{
    uint8 encoding[80] = {
        0x42, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x46, 0x72, 0x65, 0x64, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64, 
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string username = {0};
    username.value = "Fred";
    username.size = 4;
    struct text_string password = {0};
    password.value = "password1";
    password.size = 9;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential c = {0};
    c.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    c.credential_value = &upc;
    
    struct authentication expected = {0};
    expected.credential = &c;
    
    struct authentication observed = {0};
    
    int result = decode_authentication(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_authentication(&expected, &observed),
        result,
        __func__);
    free_authentication(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_request_header(void)
{
    uint8 expected[168] = {
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0xA0, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x42, 0x61, 0x72, 0x6E, 0x65, 0x79, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x07, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x32, 0x00, 
        0x42, 0x00, 0x0E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x10, 0x06, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[168] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct text_string username = {0};
    username.value = "Barney";
    username.size = 6;
    struct text_string password = {0};
    password.value = "secret2";
    password.size = 7;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential c = {0};
    c.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    c.credential_value = &upc;
    
    struct authentication a = {0};
    a.credential = &c;
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.authentication = &a;
    rh.batch_error_continuation_option = KMIP_BATCH_CONTINUE;
    rh.batch_order_option = KMIP_TRUE;
    rh.batch_count = 2;
    
    int result = encode_request_header(&ctx, &rh);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_request_header(void)
{
    uint8 encoding[168] = {
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0xA0, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x42, 0x61, 0x72, 0x6E, 0x65, 0x79, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x07, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x32, 0x00, 
        0x42, 0x00, 0x0E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x10, 0x06, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct text_string username = {0};
    username.value = "Barney";
    username.size = 6;
    struct text_string password = {0};
    password.value = "secret2";
    password.size = 7;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential c = {0};
    c.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    c.credential_value = &upc;
    
    struct authentication a = {0};
    a.credential = &c;
    
    struct request_header expected = {0};
    init_request_header(&expected);
    
    expected.protocol_version = &pv;
    expected.authentication = &a;
    expected.batch_error_continuation_option = KMIP_BATCH_CONTINUE;
    expected.batch_order_option = KMIP_TRUE;
    expected.batch_count = 2;
    
    struct request_header observed = {0};
    init_request_header(&observed);
    
    int result = decode_request_header(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_request_header(&expected, &observed),
        result,
        __func__);
    free_request_header(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_response_header(void)
{
    uint8 expected[80] = {
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[80] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514341;
    rh.batch_count = 1;
    
    int result = encode_response_header(&ctx, &rh);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_response_header(void)
{
    uint8 encoding[80] = {
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct response_header expected = {0};
    init_response_header(&expected);
    
    expected.protocol_version = &pv;
    expected.time_stamp = 1335514341;
    expected.batch_count = 1;
    
    struct response_header observed = {0};
    init_response_header(&observed);
    
    int result = decode_response_header(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_response_header(&expected, &observed),
        result,
        __func__);
    free_response_header(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_request_batch_item_get_payload(void)
{
    uint8 expected[80] = {
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[80] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    
    struct request_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.request_payload = &grp;
    
    int result = encode_request_batch_item(&ctx, &rbi);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_request_batch_item_get_payload(void)
{
    uint8 encoding[80] = {
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    
    struct request_batch_item expected = {0};
    expected.operation = KMIP_OP_GET;
    expected.request_payload = &grp;
    
    struct request_batch_item observed = {0};
    
    int result = decode_request_batch_item(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_request_batch_item(&expected, &observed),
        result,
        __func__);
    free_request_batch_item(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_response_batch_item_get_payload(void)
{
    uint8 expected[216] = {
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xD0, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7F, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[216] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    
    struct byte_string v = {0};
    v.value = value;
    v.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &v;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_TRIPLE_DES;
    kb.cryptographic_length = 168;
    
    struct symmetric_key key = {0};
    key.key_block = &kb;
    
    struct get_response_payload grp = {0};
    grp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    grp.unique_identifier = &uuid;
    grp.object = &key;
    
    struct response_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.result_status = KMIP_STATUS_SUCCESS;
    rbi.response_payload = &grp;
    
    int result = encode_response_batch_item(&ctx, &rbi);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_response_batch_item_get_payload(void)
{
    uint8 encoding[216] = {
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xD0, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7F, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    
    struct byte_string v = {0};
    v.value = value;
    v.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &v;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.key_value_type = KMIP_TYPE_STRUCTURE;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_TRIPLE_DES;
    kb.cryptographic_length = 168;
    
    struct symmetric_key key = {0};
    key.key_block = &kb;
    
    struct get_response_payload grp = {0};
    grp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    grp.unique_identifier = &uuid;
    grp.object = &key;
    
    struct response_batch_item expected = {0};
    expected.operation = KMIP_OP_GET;
    expected.result_status = KMIP_STATUS_SUCCESS;
    expected.response_payload = &grp;
    
    struct response_batch_item observed = {0};
    
    int result = decode_response_batch_item(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_response_batch_item(&expected, &observed),
        result,
        __func__);
    free_response_batch_item(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_request_message_get(void)
{
    uint8 expected[152] = {
        0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x90, 
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[152] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    
    struct request_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.request_payload = &grp;
    
    struct request_message rm = {0};
    rm.request_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_request_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_request_message_get(void)
{
    uint8 encoding[152] = {
        0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x90, 
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    
    struct request_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.request_payload = &grp;
    
    struct request_message expected = {0};
    expected.request_header = &rh;
    expected.batch_items = &rbi;
    expected.batch_count = 1;
    
    struct request_message observed = {0};
    
    int result = decode_request_message(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_request_message(&expected, &observed),
        result,
        __func__);
    free_request_message(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_response_message_get(void)
{
    uint8 expected[304] = {
        0x42, 0x00, 0x7B, 0x01, 0x00, 0x00, 0x01, 0x28, 
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE7, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xD0, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7F, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[304] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514343;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    
    struct byte_string v = {0};
    v.value = value;
    v.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &v;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_TRIPLE_DES;
    kb.cryptographic_length = 168;
    
    struct symmetric_key key = {0};
    key.key_block = &kb;
    
    struct get_response_payload grp = {0};
    grp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    grp.unique_identifier = &uuid;
    grp.object = &key;
    
    struct response_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.result_status = KMIP_STATUS_SUCCESS;
    rbi.response_payload = &grp;
    
    struct response_message rm = {0};
    rm.response_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_response_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_response_message_get(void)
{
    uint8 encoding[304] = {
        0x42, 0x00, 0x7B, 0x01, 0x00, 0x00, 0x01, 0x28, 
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE7, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xD0, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7F, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514343;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    
    struct byte_string v = {0};
    v.value = value;
    v.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &v;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.key_value_type = KMIP_TYPE_STRUCTURE;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_TRIPLE_DES;
    kb.cryptographic_length = 168;
    
    struct symmetric_key key = {0};
    key.key_block = &kb;
    
    struct get_response_payload grp = {0};
    grp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    grp.unique_identifier = &uuid;
    grp.object = &key;
    
    struct response_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.result_status = KMIP_STATUS_SUCCESS;
    rbi.response_payload = &grp;
    
    struct response_message expected = {0};
    expected.response_header = &rh;
    expected.batch_items = &rbi;
    expected.batch_count = 1;
    
    struct response_message observed = {0};
    
    int result = decode_response_message(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_response_message(&expected, &observed),
        result,
        __func__);
    free_response_message(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_template_attribute(void)
{
    uint8 expected[288] = {
        0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x01, 0x18, 
        0x42, 0x00, 0x53, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x54, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x4E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x4B, 0x65, 0x79, 0x31, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[288] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct text_string v = {0};
    v.value = "Template1";
    v.size = 9;
    
    struct name n = {0};
    n.value = &v;
    n.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    
    struct attribute a[4] = {0};
    for(int i = 0; i < 4; i++)
    {
        init_attribute(&a[i]);
    }
    
    enum cryptographic_algorithm algorithm = KMIP_CRYPTOALG_AES;
    a[0].type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    a[0].value = &algorithm;
    
    int32 length = 128;
    a[1].type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    a[1].value = &length;
    
    int32 mask = KMIP_CRYPTOMASK_ENCRYPT | KMIP_CRYPTOMASK_DECRYPT;
    a[2].type = KMIP_ATTR_CRYPTOGRAPHIC_USAGE_MASK;
    a[2].value = &mask;
    
    struct text_string value = {0};
    value.value = "Key1";
    value.size = 4;
    
    struct name name = {0};
    name.value = &value;
    name.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    a[3].type = KMIP_ATTR_NAME;
    a[3].value = &name;
    
    struct template_attribute ta = {0};
    ta.names = &n;
    ta.name_count = 1;
    ta.attributes = a;
    ta.attribute_count = ARRAY_LENGTH(a);
    
    int result = encode_template_attribute(&ctx, &ta);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_template_attribute(void)
{
    uint8 encoding[288] = {
        0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x01, 0x18, 
        0x42, 0x00, 0x53, 0x01, 0x00, 0x00, 0x00, 0x28, 
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x54, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 
        0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x4E, 0x61, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x55, 0x07, 0x00, 0x00, 0x00, 0x04, 
        0x4B, 0x65, 0x79, 0x31, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x54, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_0);
    
    struct text_string v = {0};
    v.value = "Template1";
    v.size = 9;
    
    struct name n = {0};
    n.value = &v;
    n.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    
    struct attribute a[4] = {0};
    for(int i = 0; i < 4; i++)
    {
        init_attribute(&a[i]);
    }
    
    enum cryptographic_algorithm algorithm = KMIP_CRYPTOALG_AES;
    a[0].type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    a[0].value = &algorithm;
    
    int32 length = 128;
    a[1].type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    a[1].value = &length;
    
    int32 mask = KMIP_CRYPTOMASK_ENCRYPT | KMIP_CRYPTOMASK_DECRYPT;
    a[2].type = KMIP_ATTR_CRYPTOGRAPHIC_USAGE_MASK;
    a[2].value = &mask;
    
    struct text_string value = {0};
    value.value = "Key1";
    value.size = 4;
    
    struct name name = {0};
    name.value = &value;
    name.type = KMIP_NAME_UNINTERPRETED_TEXT_STRING;
    a[3].type = KMIP_ATTR_NAME;
    a[3].value = &name;
    
    struct template_attribute expected = {0};
    expected.names = &n;
    expected.name_count = 1;
    expected.attributes = a;
    expected.attribute_count = ARRAY_LENGTH(a);
    struct template_attribute observed = {0};
    
    int result = decode_template_attribute(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_template_attribute(&expected, &observed),
        result,
        __func__);
    free_template_attribute(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

/*
The following tests cover features added in KMIP 1.1.
*/

int
test_encode_device_credential(void)
{
    uint8 expected[144] = {
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x88, 
        0x42, 0x00, 0xB0, 0x07, 0x00, 0x00, 0x00, 0x0C, 
        0x73, 0x65, 0x72, 0x4E, 0x75, 0x6D, 0x31, 0x32, 
        0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x00, 0x00, 
        0x42, 0x00, 0xA2, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x64, 0x65, 0x76, 0x49, 0x44, 0x32, 0x32, 0x33, 
        0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xAB, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x6E, 0x65, 0x74, 0x49, 0x44, 0x39, 0x30, 0x30, 
        0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA9, 0x07, 0x00, 0x00, 0x00, 0x0A, 
        0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x49, 
        0x44, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xAA, 0x07, 0x00, 0x00, 0x00, 0x0A, 
        0x6D, 0x65, 0x64, 0x69, 0x61, 0x49, 0x44, 0x33, 
        0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[144] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    struct text_string dsn = {0};
    dsn.value = "serNum123456";
    dsn.size = 12;
    
    struct text_string p = {0};
    p.value = "secret";
    p.size = 6;
    
    struct text_string di = {0};
    di.value = "devID2233";
    di.size = 9;
    
    struct text_string ni = {0};
    ni.value = "netID9000";
    ni.size = 9;
    
    struct text_string mac = {0};
    mac.value = "machineID1";
    mac.size = 10;
    
    struct text_string med = {0};
    med.value = "mediaID313";
    med.size = 10;
    
    struct device_credential dc = {0};
    dc.device_serial_number = &dsn;
    dc.password = &p;
    dc.device_identifier = &di;
    dc.network_identifier = &ni;
    dc.machine_identifier = &mac;
    dc.media_identifier = &med;
    
    int result = encode_device_credential(&ctx, &dc);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_device_credential(void)
{
    uint8 encoding[144] = {
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x88, 
        0x42, 0x00, 0xB0, 0x07, 0x00, 0x00, 0x00, 0x0C, 
        0x73, 0x65, 0x72, 0x4E, 0x75, 0x6D, 0x31, 0x32, 
        0x33, 0x34, 0x35, 0x36, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x00, 0x00, 
        0x42, 0x00, 0xA2, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x64, 0x65, 0x76, 0x49, 0x44, 0x32, 0x32, 0x33, 
        0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xAB, 0x07, 0x00, 0x00, 0x00, 0x09, 
        0x6E, 0x65, 0x74, 0x49, 0x44, 0x39, 0x30, 0x30, 
        0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA9, 0x07, 0x00, 0x00, 0x00, 0x0A, 
        0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x49, 
        0x44, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xAA, 0x07, 0x00, 0x00, 0x00, 0x0A, 
        0x6D, 0x65, 0x64, 0x69, 0x61, 0x49, 0x44, 0x33, 
        0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_1);
    
    struct text_string dsn = {0};
    dsn.value = "serNum123456";
    dsn.size = 12;
    
    struct text_string p = {0};
    p.value = "secret";
    p.size = 6;
    
    struct text_string di = {0};
    di.value = "devID2233";
    di.size = 9;
    
    struct text_string ni = {0};
    ni.value = "netID9000";
    ni.size = 9;
    
    struct text_string mac = {0};
    mac.value = "machineID1";
    mac.size = 10;
    
    struct text_string med = {0};
    med.value = "mediaID313";
    med.size = 10;
    
    struct device_credential expected = {0};
    expected.device_serial_number = &dsn;
    expected.password = &p;
    expected.device_identifier = &di;
    expected.network_identifier = &ni;
    expected.machine_identifier = &mac;
    expected.media_identifier = &med;
    
    struct device_credential observed = {0};
    
    int result = decode_device_credential(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_device_credential(&expected, &observed),
        result,
        __func__);
    free_device_credential(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_wrapping_data_with_encoding_option(void)
{
    uint8 expected[120] = {
        0x42, 0x00, 0x46, 0x01, 0x00, 0x00, 0x00, 0x70, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xA3, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[120] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_data kwd = {0};
    kwd.wrapping_method = KMIP_WRAP_ENCRYPT;
    kwd.encryption_key_info = &eki;
    kwd.encoding_option = KMIP_ENCODE_NO_ENCODING;
    
    int result = encode_key_wrapping_data(&ctx, &kwd);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_key_wrapping_data_with_encoding_option(void)
{
    uint8 encoding[120] = {
        0x42, 0x00, 0x46, 0x01, 0x00, 0x00, 0x00, 0x70, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35,
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xA3, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_1);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    init_cryptographic_parameters(&cp);
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_data expected = {0};
    expected.wrapping_method = KMIP_WRAP_ENCRYPT;
    expected.encryption_key_info = &eki;
    expected.encoding_option = KMIP_ENCODE_NO_ENCODING;
    
    struct key_wrapping_data observed = {0};
    
    int result = decode_key_wrapping_data(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_key_wrapping_data(&expected, &observed),
        result,
        __func__);
    free_key_wrapping_data(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_key_wrapping_specification_with_encoding_option(void)
{
    uint8 expected[120] = {
        0x42, 0x00, 0x47, 0x01, 0x00, 0x00, 0x00, 0x70, 
        0x42, 0x00, 0x9E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x36, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x31, 0x30, 0x30, 0x31, 0x38, 0x32, 0x64, 0x35, 
        0x2D, 0x37, 0x32, 0x62, 0x38, 0x2D, 0x34, 0x37, 
        0x61, 0x61, 0x2D, 0x38, 0x33, 0x38, 0x33, 0x2D, 
        0x34, 0x64, 0x39, 0x37, 0x64, 0x35, 0x31, 0x32, 
        0x65, 0x39, 0x38, 0x61, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0x10, 
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xA3, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[120] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    struct text_string uuid = {0};
    uuid.value = "100182d5-72b8-47aa-8383-4d97d512e98a";
    uuid.size = 36;
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_NIST_KEY_WRAP;
    
    struct encryption_key_information eki = {0};
    eki.unique_identifier = &uuid;
    eki.cryptographic_parameters = &cp;
    
    struct key_wrapping_specification kws = {0};
    kws.wrapping_method = KMIP_WRAP_ENCRYPT;
    kws.encryption_key_info = &eki;
    kws.encoding_option = KMIP_ENCODE_NO_ENCODING;
    
    int result = encode_key_wrapping_specification(&ctx, &kws);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

/*
The following tests cover features added in KMIP 1.2.
*/

int
test_encode_nonce(void)
{
    uint8 expected[40] = {
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00
    };
    
    uint8 observed[40] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_2);
    
    uint8 id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = id;
    ni.size = ARRAY_LENGTH(id);
    
    uint8 value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = value;
    nv.size = ARRAY_LENGTH(value);
    
    struct nonce n = {0};
    n.nonce_id = &ni;
    n.nonce_value = &nv;
    
    int result = encode_nonce(&ctx, &n);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_nonce(void)
{
    uint8 encoding[40] = {
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_2);
    
    uint8 id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = id;
    ni.size = ARRAY_LENGTH(id);
    
    uint8 value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = value;
    nv.size = ARRAY_LENGTH(value);
    
    struct nonce expected = {0};
    expected.nonce_id = &ni;
    expected.nonce_value = &nv;
    
    struct nonce observed = {0};
    
    int result = decode_nonce(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_nonce(&expected, &observed),
        result,
        __func__);
    free_nonce(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_attestation_credential(void)
{
    uint8 expected[128] = {
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x70,
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCB, 0x08, 0x00, 0x00, 0x00, 0x10,
        0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44,
        0x66, 0x66, 0x66, 0x66, 0x88, 0x88, 0x88, 0x88,
        0x42, 0x00, 0xCC, 0x08, 0x00, 0x00, 0x00, 0x14,
        0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x33,
        0x55, 0x55, 0x55, 0x55, 0x77, 0x77, 0x77, 0x77,
        0x99, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[128] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_2);
    
    uint8 nonce_id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = nonce_id;
    ni.size = ARRAY_LENGTH(nonce_id);
    
    uint8 nonce_value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = nonce_value;
    nv.size = ARRAY_LENGTH(nonce_value);
    
    struct nonce n = {0};
    n.nonce_id = &ni;
    n.nonce_value = &nv;
    
    uint8 measurement[16] = {
        0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44,
        0x66, 0x66, 0x66, 0x66, 0x88, 0x88, 0x88, 0x88
    };
    struct byte_string am = {0};
    am.value = measurement;
    am.size = ARRAY_LENGTH(measurement);
    
    uint8 assertion[20] = {
        0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x33,
        0x55, 0x55, 0x55, 0x55, 0x77, 0x77, 0x77, 0x77,
        0x99, 0x99, 0x99, 0x99
    };
    struct byte_string aa = {0};
    aa.value = assertion;
    aa.size = ARRAY_LENGTH(assertion);
    
    struct attestation_credential ac = {0};
    ac.nonce = &n;
    ac.attestation_type = KMIP_ATTEST_TPM_QUOTE;
    ac.attestation_measurement = &am;
    ac.attestation_assertion = &aa;
    
    int result = encode_attestation_credential(&ctx, &ac);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_attestation_credential(void)
{
    uint8 encoding[128] = {
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x70,
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCB, 0x08, 0x00, 0x00, 0x00, 0x10,
        0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44,
        0x66, 0x66, 0x66, 0x66, 0x88, 0x88, 0x88, 0x88,
        0x42, 0x00, 0xCC, 0x08, 0x00, 0x00, 0x00, 0x14,
        0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x33,
        0x55, 0x55, 0x55, 0x55, 0x77, 0x77, 0x77, 0x77,
        0x99, 0x99, 0x99, 0x99, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_2);
    
    uint8 nonce_id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = nonce_id;
    ni.size = ARRAY_LENGTH(nonce_id);
    
    uint8 nonce_value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = nonce_value;
    nv.size = ARRAY_LENGTH(nonce_value);
    
    struct nonce n = {0};
    n.nonce_id = &ni;
    n.nonce_value = &nv;
    
    uint8 measurement[16] = {
        0x22, 0x22, 0x22, 0x22, 0x44, 0x44, 0x44, 0x44,
        0x66, 0x66, 0x66, 0x66, 0x88, 0x88, 0x88, 0x88
    };
    struct byte_string am = {0};
    am.value = measurement;
    am.size = ARRAY_LENGTH(measurement);
    
    uint8 assertion[20] = {
        0x11, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x33,
        0x55, 0x55, 0x55, 0x55, 0x77, 0x77, 0x77, 0x77,
        0x99, 0x99, 0x99, 0x99
    };
    struct byte_string aa = {0};
    aa.value = assertion;
    aa.size = ARRAY_LENGTH(assertion);
    
    struct attestation_credential expected = {0};
    expected.nonce = &n;
    expected.attestation_type = KMIP_ATTEST_TPM_QUOTE;
    expected.attestation_measurement = &am;
    expected.attestation_assertion = &aa;
    
    struct attestation_credential observed = {0};
    
    int result = decode_attestation_credential(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_attestation_credential(&expected, &observed),
        result,
        __func__);
    free_attestation_credential(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_request_header_with_attestation_details(void)
{
    uint8 expected[216] = {
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0xD0, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0xD3, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x42, 0x61, 0x72, 0x6E, 0x65, 0x79, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x07, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x32, 0x00, 
        0x42, 0x00, 0x0E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x10, 0x06, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[216] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_2);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct text_string username = {0};
    username.value = "Barney";
    username.size = 6;
    struct text_string password = {0};
    password.value = "secret2";
    password.size = 7;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential c = {0};
    c.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    c.credential_value = &upc;
    
    struct authentication a = {0};
    a.credential = &c;
    
    enum attestation_type types[2] = {
        KMIP_ATTEST_TPM_QUOTE, 
        KMIP_ATTEST_SAML_ASSERTION
    };
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.attestation_capable_indicator = KMIP_TRUE;
    rh.attestation_types = types;
    rh.attestation_type_count = ARRAY_LENGTH(types);
    rh.authentication = &a;
    rh.batch_error_continuation_option = KMIP_BATCH_CONTINUE;
    rh.batch_order_option = KMIP_TRUE;
    rh.batch_count = 2;
    
    int result = encode_request_header(&ctx, &rh);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_response_header_with_attestation_details(void)
{
    uint8 expected[152] = {
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x90, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5,
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[152] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_2);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    uint8 id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = id;
    ni.size = ARRAY_LENGTH(id);
    
    uint8 value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = value;
    nv.size = ARRAY_LENGTH(value);
    
    struct nonce n = {0};
    n.nonce_id = &ni;
    n.nonce_value = &nv;
    
    enum attestation_type types[2] = {
        KMIP_ATTEST_TPM_QUOTE,
        KMIP_ATTEST_SAML_ASSERTION
    };
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514341;
    rh.nonce = &n;
    rh.attestation_types = types;
    rh.attestation_type_count = ARRAY_LENGTH(types);
    rh.batch_count = 1;
    
    int result = encode_response_header(&ctx, &rh);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_response_header_with_attestation_details(void)
{
    uint8 encoding[152] = {
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x90, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5,
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_2);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    uint8 id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = id;
    ni.size = ARRAY_LENGTH(id);
    
    uint8 value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = value;
    nv.size = ARRAY_LENGTH(value);
    
    struct nonce n = {0};
    n.nonce_id = &ni;
    n.nonce_value = &nv;
    
    enum attestation_type types[2] = {
        KMIP_ATTEST_TPM_QUOTE,
        KMIP_ATTEST_SAML_ASSERTION
    };
    
    struct response_header expected = {0};
    init_response_header(&expected);
    
    expected.protocol_version = &pv;
    expected.time_stamp = 1335514341;
    expected.nonce = &n;
    expected.attestation_types = types;
    expected.attestation_type_count = ARRAY_LENGTH(types);
    expected.batch_count = 1;
    
    struct response_header observed = {0};
    init_response_header(&observed);
    
    int result = decode_response_header(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_response_header(&expected, &observed),
        result,
        __func__);
    free_response_header(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_cryptographic_parameters_with_digital_signature_fields(void)
{
    uint8 expected[216] = {
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0xD0,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x5F, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x38, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x83, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xAE, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00 ,0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC5, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x42, 0x00, 0xCD, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCE, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCF, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD2, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD0, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD1, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[216] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_2);
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_CBC;
    cp.padding_method = KMIP_PAD_PKCS5;
    cp.hashing_algorithm = KMIP_HASH_SHA1;
    cp.key_role_type = KMIP_ROLE_KEK;
    
    cp.digital_signature_algorithm = KMIP_DIGITAL_SHA256_WITH_RSA;
    cp.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    cp.random_iv = KMIP_TRUE;
    cp.iv_length = 128;
    cp.tag_length = 64;
    cp.fixed_field_length = 64;
    cp.invocation_field_length = 64;
    cp.counter_length = 256;
    cp.initial_counter_value = 0;
    
    int result = encode_cryptographic_parameters(&ctx, &cp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_cryptographic_parameters_with_digital_signature_fields(void)
{
    uint8 encoding[216] = {
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x00, 0xD0,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x5F, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x38, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x83, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xAE, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00 ,0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC5, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x42, 0x00, 0xCD, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCE, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCF, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD2, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD0, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD1, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_2);
    
    struct cryptographic_parameters expected = {0};
    init_cryptographic_parameters(&expected);
    expected.block_cipher_mode = KMIP_BLOCK_CBC;
    expected.padding_method = KMIP_PAD_PKCS5;
    expected.hashing_algorithm = KMIP_HASH_SHA1;
    expected.key_role_type = KMIP_ROLE_KEK;
    
    expected.digital_signature_algorithm = KMIP_DIGITAL_SHA256_WITH_RSA;
    expected.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    expected.random_iv = KMIP_TRUE;
    expected.iv_length = 128;
    expected.tag_length = 64;
    expected.fixed_field_length = 64;
    expected.invocation_field_length = 64;
    expected.counter_length = 256;
    expected.initial_counter_value = 0;
    
    struct cryptographic_parameters observed = {0};
    init_cryptographic_parameters(&observed);
    
    int result = decode_cryptographic_parameters(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_cryptographic_parameters(&expected, &observed),
        result,
        __func__);
    free_cryptographic_parameters(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

/*
The following tests cover features added in KMIP 1.4.
*/

int
test_encode_cryptographic_parameters_with_mask_fields(void)
{
    uint8 expected[312] = {
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x01, 0x30,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x5F, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x38, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x83, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xAE, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00 ,0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC5, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x42, 0x00, 0xCD, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCE, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCF, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD2, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD0, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD1, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x03, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8,
        0x42, 0x01, 0x04, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[312] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_4);
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    struct byte_string ps = {0};
    ps.value = value;
    ps.size = ARRAY_LENGTH(value);
    
    struct cryptographic_parameters cp = {0};
    cp.block_cipher_mode = KMIP_BLOCK_CBC;
    cp.padding_method = KMIP_PAD_PKCS5;
    cp.hashing_algorithm = KMIP_HASH_SHA1;
    cp.key_role_type = KMIP_ROLE_KEK;
    
    cp.digital_signature_algorithm = KMIP_DIGITAL_SHA256_WITH_RSA;
    cp.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    cp.random_iv = KMIP_TRUE;
    cp.iv_length = 128;
    cp.tag_length = 64;
    cp.fixed_field_length = 64;
    cp.invocation_field_length = 64;
    cp.counter_length = 256;
    cp.initial_counter_value = 0;
    
    cp.salt_length = 32;
    cp.mask_generator = KMIP_MASKGEN_MGF1;
    cp.mask_generator_hashing_algorithm = KMIP_HASH_SHA256;
    cp.p_source = &ps;
    cp.trailer_field = 1;
    
    int result = encode_cryptographic_parameters(&ctx, &cp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_cryptographic_parameters_with_mask_fields(void)
{
    uint8 encoding[312] = {
        0x42, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x01, 0x30,
        0x42, 0x00, 0x11, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x5F, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x38, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x83, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xAE, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00 ,0x00, 0x05, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC5, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x42, 0x00, 0xCD, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCE, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCF, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD2, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD0, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xD1, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x01, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x02, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x03, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8,
        0x42, 0x01, 0x04, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_4);
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    struct byte_string ps = {0};
    ps.value = value;
    ps.size = ARRAY_LENGTH(value);
    
    struct cryptographic_parameters expected = {0};
    init_cryptographic_parameters(&expected);
    
    expected.block_cipher_mode = KMIP_BLOCK_CBC;
    expected.padding_method = KMIP_PAD_PKCS5;
    expected.hashing_algorithm = KMIP_HASH_SHA1;
    expected.key_role_type = KMIP_ROLE_KEK;
    
    expected.digital_signature_algorithm = KMIP_DIGITAL_SHA256_WITH_RSA;
    expected.cryptographic_algorithm = KMIP_CRYPTOALG_RSA;
    expected.random_iv = KMIP_TRUE;
    expected.iv_length = 128;
    expected.tag_length = 64;
    expected.fixed_field_length = 64;
    expected.invocation_field_length = 64;
    expected.counter_length = 256;
    expected.initial_counter_value = 0;
    
    expected.salt_length = 32;
    expected.mask_generator = KMIP_MASKGEN_MGF1;
    expected.mask_generator_hashing_algorithm = KMIP_HASH_SHA256;
    expected.p_source = &ps;
    expected.trailer_field = 1;
    
    struct cryptographic_parameters observed = {0};
    init_cryptographic_parameters(&observed);
    
    int result = decode_cryptographic_parameters(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_cryptographic_parameters(&expected, &observed),
        result,
        __func__);
    free_cryptographic_parameters(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_get_request_payload_with_wrap_type(void)
{
    uint8 expected[104] = {
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x37, 0x63, 0x66, 0x35, 0x32, 0x30, 0x39, 0x62, 
        0x2D, 0x36, 0x66, 0x66, 0x36, 0x2D, 0x34, 0x34, 
        0x32, 0x36, 0x2D, 0x38, 0x39, 0x39, 0x65, 0x2D, 
        0x32, 0x32, 0x62, 0x30, 0x36, 0x37, 0x38, 0x35, 
        0x39, 0x33, 0x37, 0x32, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xF8, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x41, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[104] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_4);
    
    struct text_string uuid = {0};
    uuid.value = "7cf5209b-6ff6-4426-899e-22b067859372";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    grp.key_format_type = KMIP_KEYFORMAT_PKCS1;
    grp.key_compression_type = KMIP_KEYCOMP_EC_PUB_UNCOMPRESSED;
    
    grp.key_wrap_type = KMIP_WRAPTYPE_NOT_WRAPPED;
    
    int result = encode_get_request_payload(&ctx, &grp);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_request_header_with_correlation_values(void)
{
    uint8 expected[280] = {
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x01, 0x10, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x50, 0x02, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x05, 0x07, 0x00, 0x00, 0x00, 0x08,
        0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x31,
        0x42, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00, 0x08,
        0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x31,
        0x42, 0x00, 0x07, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x42, 0x00, 0xD3, 0x06, 0x00, 0x00, 0x00, 0x08,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x23, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x24, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x25, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x99, 0x07, 0x00, 0x00, 0x00, 0x06, 
        0x42, 0x61, 0x72, 0x6E, 0x65, 0x79, 0x00, 0x00, 
        0x42, 0x00, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x07, 
        0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x32, 0x00, 
        0x42, 0x00, 0x0E, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x10, 0x06, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[280] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_4);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    struct text_string username = {0};
    username.value = "Barney";
    username.size = 6;
    struct text_string password = {0};
    password.value = "secret2";
    password.size = 7;
    
    struct username_password_credential upc = {0};
    upc.username = &username;
    upc.password = &password;
    
    struct credential c = {0};
    c.credential_type = KMIP_CRED_USERNAME_AND_PASSWORD;
    c.credential_value = &upc;
    
    struct authentication a = {0};
    a.credential = &c;
    
    enum attestation_type types[2] = {
        KMIP_ATTEST_TPM_QUOTE, 
        KMIP_ATTEST_SAML_ASSERTION
    };
    
    struct text_string ccv = {0};
    ccv.value = "client 1";
    ccv.size = 8;
    
    struct text_string scv = {0};
    scv.value = "server 1";
    scv.size = 8;
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.maximum_response_size = 4096;
    rh.asynchronous_indicator = KMIP_TRUE;
    rh.attestation_capable_indicator = KMIP_TRUE;
    rh.attestation_types = types;
    rh.attestation_type_count = ARRAY_LENGTH(types);
    rh.authentication = &a;
    rh.batch_error_continuation_option = KMIP_BATCH_CONTINUE;
    rh.batch_order_option = KMIP_TRUE;
    rh.batch_count = 2;
    
    rh.client_correlation_value = &ccv;
    rh.server_correlation_value = &scv;
    
    int result = encode_request_header(&ctx, &rh);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_encode_response_header_with_correlation_values(void)
{
    uint8 expected[184] = {
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0xB0, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5,
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x05, 0x07, 0x00, 0x00, 0x00, 0x08,
        0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x31,
        0x42, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00, 0x08,
        0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x31, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[184] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_4);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    uint8 id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = id;
    ni.size = ARRAY_LENGTH(id);
    
    uint8 value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = value;
    nv.size = ARRAY_LENGTH(value);
    
    struct nonce n = {0};
    n.nonce_id = &ni;
    n.nonce_value = &nv;
    
    enum attestation_type types[2] = {
        KMIP_ATTEST_TPM_QUOTE,
        KMIP_ATTEST_SAML_ASSERTION
    };
    
    struct text_string ccv = {0};
    ccv.value = "client 1";
    ccv.size = 8;
    
    struct text_string scv = {0};
    scv.value = "server 1";
    scv.size = 8;
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514341;
    rh.nonce = &n;
    rh.attestation_types = types;
    rh.attestation_type_count = ARRAY_LENGTH(types);
    rh.batch_count = 1;
    
    rh.client_correlation_value = &ccv;
    rh.server_correlation_value = &scv;
    
    int result = encode_response_header(&ctx, &rh);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_decode_response_header_with_correlation_values(void)
{
    uint8 encoding[184] = {
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0xB0, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5,
        0x42, 0x00, 0xC8, 0x01, 0x00, 0x00, 0x00, 0x20,
        0x42, 0x00, 0xC9, 0x08, 0x00, 0x00, 0x00, 0x04,
        0x01, 0x02, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xCA, 0x08, 0x00, 0x00, 0x00, 0x06,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0xC7, 0x05, 0x00, 0x00, 0x00, 0x04,
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x01, 0x05, 0x07, 0x00, 0x00, 0x00, 0x08,
        0x63, 0x6C, 0x69, 0x65, 0x6E, 0x74, 0x20, 0x31,
        0x42, 0x01, 0x06, 0x07, 0x00, 0x00, 0x00, 0x08,
        0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x31, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
    };
    
    struct kmip ctx = {0};
    kmip_init(&ctx, encoding, ARRAY_LENGTH(encoding), KMIP_1_4);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 0;
    
    uint8 id[4] = {0x01, 0x02, 0x03, 0x04};
    struct byte_string ni = {0};
    ni.value = id;
    ni.size = ARRAY_LENGTH(id);
    
    uint8 value[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    struct byte_string nv = {0};
    nv.value = value;
    nv.size = ARRAY_LENGTH(value);
    
    struct nonce n = {0};
    n.nonce_id = &ni;
    n.nonce_value = &nv;
    
    enum attestation_type types[2] = {
        KMIP_ATTEST_TPM_QUOTE,
        KMIP_ATTEST_SAML_ASSERTION
    };
    
    struct text_string ccv = {0};
    ccv.value = "client 1";
    ccv.size = 8;
    
    struct text_string scv = {0};
    scv.value = "server 1";
    scv.size = 8;
    
    struct response_header expected = {0};
    init_response_header(&expected);
    
    expected.protocol_version = &pv;
    expected.time_stamp = 1335514341;
    expected.nonce = &n;
    expected.attestation_types = types;
    expected.attestation_type_count = ARRAY_LENGTH(types);
    expected.batch_count = 1;
    
    expected.client_correlation_value = &ccv;
    expected.server_correlation_value = &scv;
    
    struct response_header observed = {0};
    init_response_header(&observed);
    
    int result = decode_response_header(&ctx, &observed);
    result = report_decoding_test_result(
        &ctx,
        compare_response_header(&expected, &observed),
        result,
        __func__);
    free_response_header(&ctx, &observed);
    kmip_destroy(&ctx);
    return(result);
}

/*
The following tests are taken verbatim from the KMIP 1.1 Test Cases
documentation, available here:

http://docs.oasis-open.org/kmip/testcases/v1.1/kmip-testcases-v1.1.html
*/

int
test_kmip_1_1_test_suite_3_1_1_0_a(void)
{
    /* KMIP 1.1 Test Suite - Test 3.1.1.0a */
    uint8 expected[296] = {
        0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x01, 0x20, 
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xD8, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0xC0, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x17, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x41, 0x6C, 
        0x67, 0x6F, 0x72, 0x69, 0x74, 0x68, 0x6D, 0x00, 
        0x42, 0x00, 0x0B, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x14, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x4C, 0x65, 
        0x6E, 0x67, 0x74, 0x68, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x0A, 0x07, 0x00, 0x00, 0x00, 0x18, 
        0x43, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 
        0x61, 0x70, 0x68, 0x69, 0x63, 0x20, 0x55, 0x73, 
        0x61, 0x67, 0x65, 0x20, 0x4D, 0x61, 0x73, 0x6B, 
        0x42, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[296] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    /* TODO (peter-hamilton) If protocol version omitted, pull from context? */
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 1;
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.batch_count = 1;
    
    struct attribute a[3] = {0};
    for(int i = 0; i < 3; i++)
    {
        init_attribute(&a[i]);
    }
    
    enum cryptographic_algorithm algorithm = KMIP_CRYPTOALG_AES;
    a[0].type = KMIP_ATTR_CRYPTOGRAPHIC_ALGORITHM;
    a[0].value = &algorithm;
    
    int32 length = 128;
    a[1].type = KMIP_ATTR_CRYPTOGRAPHIC_LENGTH;
    a[1].value = &length;
    
    int32 mask = KMIP_CRYPTOMASK_ENCRYPT | KMIP_CRYPTOMASK_DECRYPT;
    a[2].type = KMIP_ATTR_CRYPTOGRAPHIC_USAGE_MASK;
    a[2].value = &mask;
    
    struct template_attribute ta = {0};
    ta.attributes = a;
    ta.attribute_count = ARRAY_LENGTH(a);
    
    struct create_request_payload crp = {0};
    crp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    crp.template_attribute = &ta;
    
    struct request_batch_item rbi = {0};
    rbi.operation = KMIP_OP_CREATE;
    rbi.request_payload = &crp;
    
    struct request_message rm = {0};
    rm.request_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_request_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_kmip_1_1_test_suite_3_1_1_0_b(void)
{
    /* KMIP 1.1 Test Suite - Test 3.1.1.0b */
    uint8 expected[200] = {
        0x42, 0x00, 0x7B, 0x01, 0x00, 0x00, 0x00, 0xC0, 
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x68, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7F, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x40, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[200] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_0);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 1;
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514341;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct create_response_payload crp = {0};
    crp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    crp.unique_identifier = &uuid;
    
    struct response_batch_item rbi = {0};
    rbi.operation = KMIP_OP_CREATE;
    rbi.result_status = KMIP_STATUS_SUCCESS;
    rbi.response_payload = &crp;
    
    struct response_message rm = {0};
    rm.response_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_response_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_kmip_1_1_test_suite_3_1_1_1_a(void)
{
    /* KMIP 1.1 Test Suite - Test 3.1.1.1a */
    uint8 expected[152] = {
        0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x90, 
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[152] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 1;
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct destroy_request_payload drp = {0};
    drp.unique_identifier = &uuid;
    
    struct request_batch_item rbi = {0};
    rbi.operation = KMIP_OP_DESTROY;
    rbi.request_payload = &drp;
    
    struct request_message rm = {0};
    rm.request_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_request_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_kmip_1_1_test_suite_3_1_1_1_b(void)
{
    /* KMIP 1.1 Test Suite - Test 3.1.1.1b */
    uint8 expected[184] = {
        0x42, 0x00, 0x7B, 0x01, 0x00, 0x00, 0x00, 0xB0, 
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE5, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7F, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x66, 0x62, 0x34, 0x62, 0x35, 0x62, 0x39, 0x63, 
        0x2D, 0x36, 0x31, 0x38, 0x38, 0x2D, 0x34, 0x63, 
        0x36, 0x33, 0x2D, 0x38, 0x31, 0x34, 0x32, 0x2D, 
        0x66, 0x65, 0x39, 0x63, 0x33, 0x32, 0x38, 0x31, 
        0x32, 0x39, 0x66, 0x63, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[184] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 1;
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514341;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "fb4b5b9c-6188-4c63-8142-fe9c328129fc";
    uuid.size = 36;
    
    struct destroy_response_payload drp = {0};
    drp.unique_identifier = &uuid;
    
    struct response_batch_item rbi = {0};
    rbi.operation = KMIP_OP_DESTROY;
    rbi.result_status = KMIP_STATUS_SUCCESS;
    rbi.response_payload = &drp;
    
    struct response_message rm = {0};
    rm.response_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_response_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_kmip_1_1_test_suite_3_1_3_2_a(void)
{
    /* KMIP 1.1 Test Suite - Test 3.1.3.2a */
    uint8 expected[152] = {
        0x42, 0x00, 0x78, 0x01, 0x00, 0x00, 0x00, 0x90, 
        0x42, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x38, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x79, 0x01, 0x00, 0x00, 0x00, 0x30, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[152] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 1;
    
    struct request_header rh = {0};
    init_request_header(&rh);
    
    rh.protocol_version = &pv;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    struct get_request_payload grp = {0};
    grp.unique_identifier = &uuid;
    
    struct request_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.request_payload = &grp;
    
    struct request_message rm = {0};
    rm.request_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_request_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

int
test_kmip_1_1_test_suite_3_1_3_2_b(void)
{
    uint8 expected[304] = {
        0x42, 0x00, 0x7B, 0x01, 0x00, 0x00, 0x01, 0x28, 
        0x42, 0x00, 0x7A, 0x01, 0x00, 0x00, 0x00, 0x48, 
        0x42, 0x00, 0x69, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x6A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x6B, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x92, 0x09, 0x00, 0x00, 0x00, 0x08, 
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x9A, 0x54, 0xE7, 
        0x42, 0x00, 0x0D, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x42, 0x00, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xD0, 
        0x42, 0x00, 0x5C, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7F, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x7C, 0x01, 0x00, 0x00, 0x00, 0xA8, 
        0x42, 0x00, 0x57, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x94, 0x07, 0x00, 0x00, 0x00, 0x24, 
        0x34, 0x39, 0x61, 0x31, 0x63, 0x61, 0x38, 0x38, 
        0x2D, 0x36, 0x62, 0x65, 0x61, 0x2D, 0x34, 0x66, 
        0x62, 0x32, 0x2D, 0x62, 0x34, 0x35, 0x30, 0x2D, 
        0x37, 0x65, 0x35, 0x38, 0x38, 0x30, 0x32, 0x63, 
        0x33, 0x30, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x8F, 0x01, 0x00, 0x00, 0x00, 0x60, 
        0x42, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x58, 
        0x42, 0x00, 0x42, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x45, 0x01, 0x00, 0x00, 0x00, 0x20, 
        0x42, 0x00, 0x43, 0x08, 0x00, 0x00, 0x00, 0x18, 
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8, 
        0x42, 0x00, 0x28, 0x05, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 
        0x42, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x00, 0x04, 
        0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0x00
    };
    
    uint8 observed[304] = {0};
    struct kmip ctx = {0};
    kmip_init(&ctx, observed, ARRAY_LENGTH(observed), KMIP_1_1);
    
    struct protocol_version pv = {0};
    pv.major = 1;
    pv.minor = 1;
    
    struct response_header rh = {0};
    init_response_header(&rh);
    
    rh.protocol_version = &pv;
    rh.time_stamp = 1335514343;
    rh.batch_count = 1;
    
    struct text_string uuid = {0};
    uuid.value = "49a1ca88-6bea-4fb2-b450-7e58802c3038";
    uuid.size = 36;
    
    uint8 value[24] = {
        0x73, 0x67, 0x57, 0x80, 0x51, 0x01, 0x2A, 0x6D, 
        0x13, 0x4A, 0x85, 0x5E, 0x25, 0xC8, 0xCD, 0x5E, 
        0x4C, 0xA1, 0x31, 0x45, 0x57, 0x29, 0xD3, 0xC8
    };
    
    struct byte_string v = {0};
    v.value = value;
    v.size = ARRAY_LENGTH(value);
    
    struct key_value kv = {0};
    kv.key_material = &v;
    
    struct key_block kb = {0};
    kb.key_format_type = KMIP_KEYFORMAT_RAW;
    kb.key_value = &kv;
    kb.cryptographic_algorithm = KMIP_CRYPTOALG_TRIPLE_DES;
    kb.cryptographic_length = 168;
    
    struct symmetric_key key = {0};
    key.key_block = &kb;
    
    struct get_response_payload grp = {0};
    grp.object_type = KMIP_OBJTYPE_SYMMETRIC_KEY;
    grp.unique_identifier = &uuid;
    grp.object = &key;
    
    struct response_batch_item rbi = {0};
    rbi.operation = KMIP_OP_GET;
    rbi.result_status = KMIP_STATUS_SUCCESS;
    rbi.response_payload = &grp;
    
    struct response_message rm = {0};
    rm.response_header = &rh;
    rm.batch_items = &rbi;
    rm.batch_count = 1;
    
    int result = encode_response_message(&ctx, &rm);
    result = report_encoding_test_result(
        &ctx,
        expected,
        observed,
        result,
        __func__);
    kmip_destroy(&ctx);
    return(result);
}

/* Test Harness */

void
run_tests(void)
{
    int num_tests = 135;
    int num_failures = 0;
    
    printf("Tests\n");
    printf("=====\n");
    
    printf("\nKMIP 1.0 Feature Tests\n");
    printf("----------------------\n");
    num_failures += test_buffer_full_and_resize();
    num_failures += test_is_tag_next();
    num_failures += test_get_num_items_next();
    num_failures += test_get_num_items_next_with_partial_item();
    num_failures += test_get_num_items_next_with_mismatch_item();
    num_failures += test_get_num_items_next_with_no_matches();
    num_failures += test_get_num_items_next_with_non_structures();
    
    printf("\n");
    num_failures += test_decode_int8_be();
    num_failures += test_decode_int32_be();
    num_failures += test_decode_int64_be();
    num_failures += test_decode_integer();
    num_failures += test_decode_long();
    num_failures += test_decode_enum();
    num_failures += test_decode_bool();
    num_failures += test_decode_text_string();
    num_failures += test_decode_byte_string();
    num_failures += test_decode_date_time();
    num_failures += test_decode_interval();
    num_failures += test_decode_name();
    num_failures += test_decode_attribute_unique_identifier();
    num_failures += test_decode_attribute_name();
    num_failures += test_decode_attribute_object_type();
    num_failures += test_decode_attribute_cryptographic_algorithm();
    num_failures += test_decode_attribute_cryptographic_length();
    num_failures += test_decode_attribute_operation_policy_name();
    num_failures += test_decode_attribute_cryptographic_usage_mask();
    num_failures += test_decode_attribute_state();
    num_failures += test_decode_template_attribute();
    num_failures += test_decode_protocol_version();
    num_failures += test_decode_key_material_byte_string();
    num_failures += test_decode_key_material_transparent_symmetric_key();
    num_failures += test_decode_key_value();
    num_failures += test_decode_key_value_with_attributes();
    num_failures += test_decode_cryptographic_parameters();
    num_failures += test_decode_encryption_key_information();
    num_failures += test_decode_mac_signature_key_information();
    num_failures += test_decode_key_wrapping_data();
    num_failures += test_decode_key_block_key_value_byte_string();
    num_failures += test_decode_key_block_key_value_structure();
    num_failures += test_decode_symmetric_key();
    num_failures += test_decode_public_key();
    num_failures += test_decode_private_key();
    num_failures += test_decode_key_wrapping_specification();
    num_failures += test_decode_create_request_payload();
    num_failures += test_decode_create_response_payload();
    num_failures += test_decode_create_response_payload_with_template_attribute();
    num_failures += test_decode_get_request_payload();
    num_failures += test_decode_get_response_payload();
    num_failures += test_decode_destroy_request_payload();
    num_failures += test_decode_destroy_response_payload();
    num_failures += test_decode_response_batch_item_get_payload();
    num_failures += test_decode_username_password_credential();
    num_failures += test_decode_credential_username_password_credential();
    num_failures += test_decode_authentication_username_password_credential();
    num_failures += test_decode_request_header();
    num_failures += test_decode_response_header();
    num_failures += test_decode_request_batch_item_get_payload();
    num_failures += test_decode_request_message_get();
    num_failures += test_decode_response_message_get();
    
    printf("\n");
    num_failures += test_encode_integer();
    num_failures += test_encode_long();
    num_failures += test_encode_enum();
    num_failures += test_encode_bool();
    num_failures += test_encode_text_string();
    num_failures += test_encode_byte_string();
    num_failures += test_encode_date_time();
    num_failures += test_encode_interval();
    num_failures += test_encode_name();
    num_failures += test_encode_attribute_unique_identifier();
    num_failures += test_encode_attribute_name();
    num_failures += test_encode_attribute_object_type();
    num_failures += test_encode_attribute_cryptographic_algorithm();
    num_failures += test_encode_attribute_cryptographic_length();
    num_failures += test_encode_attribute_operation_policy_name();
    num_failures += test_encode_attribute_cryptographic_usage_mask();
    num_failures += test_encode_attribute_state();
    num_failures += test_encode_protocol_version();
    num_failures += test_encode_cryptographic_parameters();
    num_failures += test_encode_encryption_key_information();
    num_failures += test_encode_mac_signature_key_information();
    num_failures += test_encode_key_wrapping_data();
    num_failures += test_encode_key_material_byte_string();
    num_failures += test_encode_key_material_transparent_symmetric_key();
    num_failures += test_encode_key_value();
    num_failures += test_encode_key_value_with_attributes();
    num_failures += test_encode_key_block_key_value_byte_string();
    num_failures += test_encode_key_block_key_value_structure();
    num_failures += test_encode_symmetric_key();
    num_failures += test_encode_public_key();
    num_failures += test_encode_private_key();
    num_failures += test_encode_key_wrapping_specification();
    num_failures += test_encode_create_request_payload();
    num_failures += test_encode_create_response_payload();
    num_failures += test_encode_create_response_payload_with_template_attribute();
    num_failures += test_encode_get_request_payload();
    num_failures += test_encode_get_request_payload_with_format_compression();
    num_failures += test_encode_get_request_payload_with_wrapping_spec();
    num_failures += test_encode_get_response_payload();
    num_failures += test_encode_destroy_request_payload();
    num_failures += test_encode_destroy_response_payload();
    num_failures += test_encode_username_password_credential();
    num_failures += test_encode_credential_username_password_credential();
    num_failures += test_encode_authentication_username_password_credential();
    num_failures += test_encode_request_header();
    num_failures += test_encode_response_header();
    num_failures += test_encode_request_batch_item_get_payload();
    num_failures += test_encode_response_batch_item_get_payload();
    num_failures += test_encode_request_message_get();
    num_failures += test_encode_response_message_get();
    num_failures += test_encode_template_attribute();
    
    printf("\nKMIP 1.1 Feature Tests\n");
    printf("----------------------\n");
    num_failures += test_decode_device_credential();
    num_failures += test_decode_key_wrapping_data_with_encoding_option();
    
    printf("\n");
    num_failures += test_encode_device_credential();
    num_failures += test_encode_key_wrapping_data_with_encoding_option();
    num_failures += test_encode_key_wrapping_specification_with_encoding_option();
    
    printf("\nKMIP 1.1 Test Suite Test Cases\n");
    printf("------------------------------\n");
    num_failures += test_kmip_1_1_test_suite_3_1_1_0_a();
    num_failures += test_kmip_1_1_test_suite_3_1_1_0_b();
    num_failures += test_kmip_1_1_test_suite_3_1_1_1_a();
    num_failures += test_kmip_1_1_test_suite_3_1_1_1_b();
    num_failures += test_kmip_1_1_test_suite_3_1_3_2_a();
    num_failures += test_kmip_1_1_test_suite_3_1_3_2_b();
    
    printf("\nKMIP 1.2 Feature Tests\n");
    printf("----------------------\n");
    num_failures += test_decode_nonce();
    num_failures += test_decode_attestation_credential();
    num_failures += test_decode_response_header_with_attestation_details();
    num_failures += test_decode_cryptographic_parameters_with_digital_signature_fields();
    
    printf("\n");
    num_failures += test_encode_nonce();
    num_failures += test_encode_attestation_credential();
    num_failures += test_encode_request_header_with_attestation_details();
    num_failures += test_encode_response_header_with_attestation_details();
    num_failures += test_encode_cryptographic_parameters_with_digital_signature_fields();
    
    printf("\nKMIP 1.4 Feature Tests\n");
    printf("----------------------\n");
    num_failures += test_decode_cryptographic_parameters_with_mask_fields();
    num_failures += test_decode_response_header_with_correlation_values();
    
    printf("\n");
    num_failures += test_encode_cryptographic_parameters_with_mask_fields();
    num_failures += test_encode_get_request_payload_with_wrap_type();
    num_failures += test_encode_request_header_with_correlation_values();
    num_failures += test_encode_response_header_with_correlation_values();
    
    printf("\nSummary\n");
    printf("================\n");
    printf("Total tests: %d\n", num_tests);
    printf("       PASS: %d\n", num_tests - num_failures);
    printf("    FAILURE: %d\n", num_failures);
}

int
main(int argc, char **argv)
{
    (void)argv;
    
    if(argc == 1)
    {
        run_tests();
    }
    else
    {
        while(1)
        {
            run_tests();
        }
    }
    
    return(0);
}
